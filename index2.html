This is the **"RPG Update"**. I have overhauled the map generation to prevent diagonal blocking and restored the RPG elements (Leveling up, Spell Rarity, and Specific Spell Types).

### **New Features & Fixes:**

1.  **Map Fix (Diagonal Pinch Removal):** The generator now runs a "Safety Pass." If it detects two walls touching diagonally (which blocks movement), it knocks one down. No more stuck enemies or players.
2.  **RPG Progression Restored:**
      * **Leveling:** You gain XP. Leveling up increases your **Max HP** and **Global Damage**.
      * **Spell Drops:** Scrolls are now specific (Fire, Ice, Poison, Lightning).
      * **Spell Upgrading:** If you pick up a scroll for a spell you *already* have, it **Levels Up** that specific spell (e.g., "Fireball Lvl 2"), making it bigger and stronger.
3.  **Visuals:** Added specific particles for different elements (Red for Fire, Green for Poison, etc.).

### **Copy this code into your `.html` file:**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mage Quest: RPG Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; touch-action: none; }
        
        /* HUD */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            pointer-events: none; color: white; text-shadow: 2px 2px 0 #000; z-index: 10;
            display: flex; justify-content: space-between; box-sizing: border-box;
        }
        .stat-group { background: rgba(0,0,0,0.7); padding: 5px 10px; border: 1px solid #444; border-radius: 5px; }
        
        canvas { display: block; image-rendering: pixelated; }
        
        /* Notifications */
        #notif {
            position: absolute; top: 15%; left: 50%; transform: translate(-50%, -50%);
            color: gold; font-size: 20px; font-weight: bold; text-shadow: 0 0 5px black;
            opacity: 0; transition: opacity 0.5s; pointer-events: none; text-align: center; width: 100%;
        }

        /* Controls */
        #controls {
            position: absolute; bottom: 20px; width: 100%; height: 160px;
            pointer-events: none; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
        }
        .dpad { position: relative; width: 140px; height: 140px; pointer-events: auto; }
        .btn {
            position: absolute; width: 45px; height: 45px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px; color: white; display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer;
        }
        .btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); border-color: white; }
        
        /* Positioning */
        .up { top: 0; left: 47px; } .down { bottom: 0; left: 47px; }
        .left { top: 47px; left: 0; } .right { top: 47px; right: 0; }
        
        #dashBtn {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 70px; height: 70px; border-radius: 50%; background: #0088ff;
            border: 4px solid #0055aa; pointer-events: auto; box-shadow: 0 0 10px #0088ff;
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
        }
        #dashBtn:active { background: #66b2ff; transform: translateX(-50%) scale(0.95); }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat-group">
        <div id="hpUi">‚ù§Ô∏è 100/100</div>
        <div id="xpUi" style="color:yellow">‚≠ê Lvl 1 (0 XP)</div>
    </div>
    <div class="stat-group" style="text-align: right;">
        <div id="spellUi" style="color:cyan">‚ú® Magic Bolt (Lvl 1)</div>
        <div id="floorUi" style="color:#aaa">Floor 1</div>
    </div>
</div>

<div id="notif">Welcome Mage!</div>
<canvas id="game"></canvas>

<div id="controls">
    <div class="dpad" id="movePad">
        <div class="btn up" data-k="w">‚¨ÜÔ∏è</div><div class="btn down" data-k="s">‚¨áÔ∏è</div>
        <div class="btn left" data-k="a">‚¨ÖÔ∏è</div><div class="btn right" data-k="d">‚û°Ô∏è</div>
    </div>
    <div id="dashBtn">DASH</div>
    <div class="dpad" id="firePad">
        <div class="btn up" data-k="ArrowUp">üî•</div><div class="btn down" data-k="ArrowDown">üî•</div>
        <div class="btn left" data-k="ArrowLeft">üî•</div><div class="btn right" data-k="ArrowRight">üî•</div>
    </div>
</div>

<script>
// --- CONFIG & DB ---
const TILE = 48;
const SPELL_DB = {
    fire: { name: "Fireball", color: "#ff4400", scale: 1.2, speed: 7, effect: "explode" },
    ice: { name: "Ice Shard", color: "#00eeff", scale: 0.8, speed: 9, effect: "pierce" },
    poison: { name: "Venom Orb", color: "#00ff00", scale: 1.0, speed: 5, effect: "linger" },
    lightning: { name: "Thunder", color: "#ffff00", scale: 0.6, speed: 12, effect: "fast" }
};

// --- ENGINE STATE ---
const C = document.getElementById('game');
const X = C.getContext('2d');
let W, H;

const GAME = {
    map: [], size: 30, floor: 1,
    cam: { x:0, y:0 },
    keys: {},
    particles: [],
    mobs: [],
    loot: [],
    shots: [],
    popups: [],
    exit: {x:0, y:0, open:false}
};

const PL = {
    x: 1, y: 1, rx: 1, ry: 1,
    hp: 100, maxHp: 100,
    xp: 0, lvl: 1, nextXp: 100,
    dash: 0,
    moving: false,
    cool: 0,
    spell: { id: 'fire', lvl: 1, ...SPELL_DB.fire }
};

// --- INIT ---
window.onkeydown = e => GAME.keys[e.key] = true;
window.onkeyup = e => GAME.keys[e.key] = false;
window.addEventListener('resize', resize);

function resize() {
    W = C.width = window.innerWidth;
    H = C.height = window.innerHeight;
}

function init() {
    resize();
    genLevel();
    loop();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// --- UPDATE LOGIC ---
function update() {
    // 1. Level Up Check
    if (PL.xp >= PL.nextXp) {
        PL.lvl++;
        PL.xp -= PL.nextXp;
        PL.nextXp = Math.floor(PL.nextXp * 1.5);
        PL.maxHp += 20;
        PL.hp = PL.maxHp;
        addPopup(PL.rx, PL.ry, "LEVEL UP!", "gold");
        notify(`Reaching Level ${PL.lvl}! Stats Up!`);
    }

    // 2. Movement & Collision
    let dx = 0, dy = 0;
    if (GAME.keys.w) dy = -1;
    if (GAME.keys.s) dy = 1;
    if (GAME.keys.a) dx = -1;
    if (GAME.keys.d) dx = 1;

    if ((dx || dy) && !PL.moving) {
        let nx = PL.x + dx, ny = PL.y + dy;
        // Collision: Check Walls AND Diagonal blockades
        if (!isWall(nx, ny)) {
            // Strict diagonal check: Don't allow passing if both cardinal neighbors are walls
            // (e.g. moving NE requires N or E to be open)
            let nFree = !isWall(PL.x, ny);
            let eFree = !isWall(nx, PL.y);
            if(dx !== 0 && dy !== 0 && !nFree && !eFree) {
                // Blocked diagonally
            } else {
                PL.x = nx; PL.y = ny;
                PL.moving = true;
                if (nx === GAME.exit.x && ny === GAME.exit.y && GAME.exit.open) nextFloor();
            }
        }
    }

    // Smooth Lerp
    PL.rx += (PL.x - PL.rx) * 0.25;
    PL.ry += (PL.y - PL.ry) * 0.25;
    if (Math.abs(PL.x - PL.rx) < 0.01) PL.moving = false;

    // Camera
    GAME.cam.x += ((PL.rx * TILE - W/2) - GAME.cam.x) * 0.1;
    GAME.cam.y += ((PL.ry * TILE - H/2) - GAME.cam.y) * 0.1;

    // 3. Dash
    if (PL.dash > 0) PL.dash--;
    if (GAME.keys[' '] && PL.dash <= 0) {
        let ddx = dx || (Math.random()>0.5?1:-1), ddy = dy || 0;
        let tx = PL.x + ddx*2, ty = PL.y + ddy*2;
        if (!isWall(tx, ty)) {
            PL.x = tx; PL.y = ty; PL.rx = tx; PL.ry = ty;
            PL.dash = 50;
            addPopup(PL.rx, PL.ry, "DASH!", "cyan");
            // Trailing Particles
            for(let i=0; i<10; i++) addPart(PL.rx*TILE+24, PL.ry*TILE+24, "white", -ddx*3, -ddy*3, 1);
        }
    }

    // 4. Combat / Shooting
    if (PL.cool > 0) PL.cool--;
    if (PL.cool <= 0) {
        let sx=0, sy=0;
        if (GAME.keys.ArrowUp) sy = -1;
        else if (GAME.keys.ArrowDown) sy = 1;
        else if (GAME.keys.ArrowLeft) sx = -1;
        else if (GAME.keys.ArrowRight) sx = 1;

        if (sx || sy) {
            let dmg = (10 + (PL.lvl * 2)) * (1 + (PL.spell.lvl * 0.2)); // RPG Damage Formula
            GAME.shots.push({ 
                x: PL.rx, y: PL.ry, vx: sx*0.3, vy: sy*0.3, 
                life: 50, color: PL.spell.color, dmg: dmg, 
                scale: PL.spell.scale + (PL.spell.lvl * 0.1) // Spells get bigger
            });
            PL.cool = 15;
        }
    }

    // 5. Entities Update
    GAME.shots.forEach((s, i) => {
        s.x += s.vx * (PL.spell.speed/5); 
        s.y += s.vy * (PL.spell.speed/5);
        s.life--;
        addPart(s.x*TILE+24, s.y*TILE+24, s.color, -s.vx*5, -s.vy*5, 0.3); // Trail
        
        if (isWall(Math.round(s.x), Math.round(s.y))) s.life = 0; // Wall hit

        GAME.mobs.forEach(m => {
            if (Math.hypot(m.x - s.x, m.y - s.y) < 0.7) {
                m.hp -= s.dmg;
                s.life = 0;
                addPopup(m.x, m.y, Math.floor(s.dmg), "orange");
                addPart(m.x*TILE+24, m.y*TILE+24, "red", 0, 0, 1.5); // Blood
                if (m.hp <= 0) killMob(m);
            }
        });
        if (s.life <= 0) GAME.shots.splice(i, 1);
    });

    GAME.mobs.forEach((m, i) => {
        // AI: Simple Pathing
        let dist = Math.hypot(PL.x - m.x, PL.y - m.y);
        if (dist < 8) {
            let mx = (PL.x - m.x) * 0.035;
            let my = (PL.y - m.y) * 0.035;
            // Prevent diagonal sticking for mobs too
            let nx = m.x + mx;
            let ny = m.y + my;
            if(!isWall(Math.round(nx), Math.round(ny))) {
                m.x = nx; m.y = ny;
            }
        }
        
        // Merge Logic
        for (let j = i + 1; j < GAME.mobs.length; j++) {
            let o = GAME.mobs[j];
            if (Math.hypot(m.x - o.x, m.y - o.y) < 0.6) {
                m.hp += o.hp; m.maxHp += o.maxHp; m.scale += 0.4;
                m.color = "purple"; // Boss color
                addPopup(m.x, m.y, "MERGE!", "magenta");
                GAME.mobs.splice(j, 1);
            }
        }

        if (dist < 0.6) {
            PL.hp -= 0.5;
            if(Math.random()<0.1) addPopup(PL.rx, PL.ry, "-1", "red");
            if(PL.hp <= 0) { location.reload(); }
        }
    });

    // Loot
    GAME.loot.forEach((l, i) => {
        if (Math.hypot(PL.rx - l.x, PL.ry - l.y) < 0.8) {
            if (l.type === 'spell') {
                if (PL.spell.id === l.id) {
                    PL.spell.lvl++;
                    addPopup(PL.rx, PL.ry, "SPELL UPGRADE!", "cyan");
                    notify(`${PL.spell.name} is now Level ${PL.spell.lvl}!`);
                } else {
                    PL.spell = { id: l.id, lvl: 1, ...SPELL_DB[l.id] };
                    addPopup(PL.rx, PL.ry, "NEW SPELL!", l.color);
                    notify(`Equipped: ${PL.spell.name}`);
                }
            } else {
                PL.hp = Math.min(PL.maxHp, PL.hp + 30);
                addPopup(PL.rx, PL.ry, "+30 HP", "lime");
            }
            GAME.loot.splice(i, 1);
        }
    });

    // Particles
    GAME.particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        if (p.life <= 0) GAME.particles.splice(i, 1);
    });

    // HUD
    document.getElementById('hpUi').innerText = `‚ù§Ô∏è ${Math.floor(PL.hp)}/${PL.maxHp}`;
    document.getElementById('xpUi').innerText = `‚≠ê Lvl ${PL.lvl} (${Math.floor(PL.xp)}/${PL.nextXp} XP)`;
    document.getElementById('spellUi').innerText = `‚ú® ${PL.spell.name} (Lvl ${PL.spell.lvl})`;
    document.getElementById('floorUi').innerText = `Floor ${GAME.floor}`;
}

// --- DRAWING ---
function draw() {
    X.fillStyle = "#111";
    X.fillRect(0, 0, W, H);
    X.save();
    X.translate(-GAME.cam.x, -GAME.cam.y);

    // Map
    let cx = Math.floor(GAME.cam.x / TILE);
    let cy = Math.floor(GAME.cam.y / TILE);
    for (let y = cy; y < cy + H/TILE + 1; y++) {
        for (let x = cx; x < cx + W/TILE + 1; x++) {
            if (isWall(x, y)) {
                X.fillStyle = "#333";
                X.fillRect(x*TILE, y*TILE, TILE, TILE);
                X.fillStyle = "#1a1a1a";
                X.fillRect(x*TILE, y*TILE+40, TILE, 8); // Fake 3D depth
            } else {
                X.strokeStyle = "#222";
                X.lineWidth = 2;
                X.strokeRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
    }

    // Loot
    GAME.loot.forEach(l => {
        X.font = "30px serif";
        X.fillStyle = l.color || "white";
        X.fillText(l.icon, l.x*TILE+10, l.y*TILE+35);
    });
    
    // Exit
    if (GAME.exit.open) {
        X.font = "40px serif";
        X.fillText("üåÄ", GAME.exit.x*TILE+5, GAME.exit.y*TILE+40);
    } else {
        X.font = "40px serif";
        X.fillText("üîí", GAME.exit.x*TILE+5, GAME.exit.y*TILE+40);
    }

    // Mobs
    GAME.mobs.forEach(m => {
        let s = (m.scale || 1) * TILE;
        X.fillStyle = m.color || "red";
        X.fillRect(m.x*TILE - s/2 + 24, m.y*TILE - s/2 + 24, s, s);
        // HP
        X.fillStyle = "#550000"; X.fillRect(m.x*TILE, m.y*TILE-10, TILE, 4);
        X.fillStyle = "#00ff00"; X.fillRect(m.x*TILE, m.y*TILE-10, TILE*(m.hp/m.maxHp), 4);
    });

    // Player
    X.font = "40px serif";
    X.fillText("üßô‚Äç‚ôÇÔ∏è", PL.rx*TILE+5, PL.ry*TILE+40);

    // Particles
    GAME.particles.forEach(p => {
        X.fillStyle = p.c;
        X.globalAlpha = p.life;
        X.beginPath();
        X.arc(p.x, p.y, p.r || 3, 0, Math.PI*2);
        X.fill();
    });
    X.globalAlpha = 1;

    // Popups
    GAME.popups.forEach((p, i) => {
        p.life--; p.y -= 0.02;
        X.fillStyle = p.c;
        X.font = "bold 16px sans-serif";
        X.fillText(p.t, p.x*TILE, p.y*TILE);
        if(p.life <= 0) GAME.popups.splice(i,1);
    });

    X.restore();
}

// --- GENERATOR (Diagonal Pinch Fix) ---
function genLevel() {
    GAME.size = 20 + GAME.floor * 5;
    let m = [];
    
    // 1. Noise
    for(let y=0; y<GAME.size; y++) {
        let r=[]; 
        for(let x=0; x<GAME.size; x++) 
            r.push((x==0||y==0||x==GAME.size-1||y==GAME.size-1 || Math.random()<0.45) ? 1 : 0);
        m.push(r);
    }
    // 2. Smooth
    for(let i=0; i<4; i++) {
        let nm = JSON.parse(JSON.stringify(m));
        for(let y=1; y<GAME.size-1; y++) for(let x=1; x<GAME.size-1; x++) {
            let n=0;
            for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) if(m[y+dy][x+dx]) n++;
            if(n>=5) nm[y][x]=1; else if(n<=3) nm[y][x]=0;
        }
        m = nm;
    }
    
    // 3. DIAGONAL PINCH REMOVAL (The Fix)
    // Ensures if (0,0) and (1,1) are floors, (0,1) and (1,0) aren't BOTH walls.
    for(let y=1; y<GAME.size-1; y++) {
        for(let x=1; x<GAME.size-1; x++) {
            if(m[y][x] === 0 && m[y+1][x+1] === 0) {
                // We have a diagonal floor connection
                if(m[y][x+1] === 1 && m[y+1][x] === 1) {
                    // It's pinched by walls! Remove one.
                    m[y][x+1] = 0; 
                }
            }
            if(m[y][x+1] === 0 && m[y+1][x] === 0) {
                if(m[y][x] === 1 && m[y+1][x+1] === 1) {
                    m[y][x] = 0;
                }
            }
        }
    }

    // 4. Flood Fill & Tunneling (Connectivity)
    let start = null;
    for(let y=1; y<GAME.size-1; y++) for(let x=1; x<GAME.size-1; x++) if(!m[y][x]) { start={x,y}; break; }
    if(!start) return genLevel(); // Bad map
    
    let visited = new Set();
    let q = [start];
    visited.add(`${start.x},${start.y}`);
    while(q.length) {
        let c = q.pop();
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy])=>{
            let nx=c.x+dx, ny=c.y+dy;
            if(!m[ny][nx] && !visited.has(`${nx},${ny}`)) { visited.add(`${nx},${ny}`); q.push({x:nx,y:ny}); }
        });
    }
    
    // Dig to islands
    for(let y=1; y<GAME.size-1; y++) for(let x=1; x<GAME.size-1; x++) {
        if(!m[y][x] && !visited.has(`${x},${y}`)) {
            let cur={x,y};
            while(m[cur.y][cur.x]!==0 || !visited.has(`${cur.x},${cur.y}`)) {
                m[cur.y][cur.x]=0;
                if(cur.x < start.x) cur.x++; else if(cur.x > start.x) cur.x--;
                if(cur.y < start.y) cur.y++; else if(cur.y > start.y) cur.y--;
            }
        }
    }
    GAME.map = m;
    
    // 5. Populate
    PL.x=start.x; PL.y=start.y; PL.rx=start.x; PL.ry=start.y;
    
    // Loot (Spells & Potions)
    GAME.loot = [];
    for(let i=0; i<5; i++) {
        let p = rndPos();
        let isSpell = Math.random() > 0.4;
        let keys = Object.keys(SPELL_DB);
        let key = keys[Math.floor(Math.random()*keys.length)];
        GAME.loot.push({
            x:p.x, y:p.y, 
            type: isSpell ? 'spell' : 'heal',
            id: key,
            icon: isSpell ? 'üìú' : 'üç∑',
            color: isSpell ? SPELL_DB[key].color : 'red'
        });
    }
    
    // Mobs
    GAME.mobs = [];
    for(let i=0; i<4 + GAME.floor; i++) {
        let p = rndPos();
        if(Math.hypot(p.x-PL.x, p.y-PL.y) > 5)
            GAME.mobs.push({x:p.x, y:p.y, hp:20+GAME.floor*5, maxHp:20+GAME.floor*5, scale:1});
    }

    // Exit
    let ep = rndPos();
    GAME.exit = { ...ep, open: false };
    
    notify(`Floor ${GAME.floor}`);
}

// --- UTILS ---
function isWall(x, y) {
    if(x<0||y<0||x>=GAME.size||y>=GAME.size) return true;
    return GAME.map[y][x];
}
function rndPos() {
    let x,y; do { x=Math.floor(Math.random()*GAME.size); y=Math.floor(Math.random()*GAME.size); } while(isWall(x,y));
    return {x,y};
}
function addPart(x, y, c, vx, vy, r) { GAME.particles.push({x,y,c,vx:(Math.random()-0.5)+vx, vy:(Math.random()-0.5)+vy, life:1, r}); }
function addPopup(x, y, t, c) { GAME.popups.push({x,y,t,c,life:100}); }
function notify(m) { let e=document.getElementById('notif'); e.innerText=m; e.style.opacity=1; setTimeout(()=>e.style.opacity=0, 2000); }
function killMob(m) { 
    GAME.mobs = GAME.mobs.filter(e=>e!==m); 
    PL.xp += 20; 
    addPopup(m.x, m.y, "+20 XP", "white");
    if(GAME.mobs.length===0) { GAME.exit.open=true; notify("Portal Open!"); }
}
function nextFloor() { GAME.floor++; genLevel(); }

// Controls (Mouse/Touch)
document.querySelectorAll('.btn').forEach(b => {
    b.onpointerdown = e => { GAME.keys[b.dataset.k] = true; e.preventDefault(); };
    b.onpointerup = e => { GAME.keys[b.dataset.k] = false; e.preventDefault(); };
});
document.getElementById('dashBtn').onpointerdown = e => { GAME.keys[' '] = true; e.preventDefault(); };
document.getElementById('dashBtn').onpointerup = e => { GAME.keys[' '] = false; e.preventDefault(); };

init();
</script>
</body>
</html>
```
