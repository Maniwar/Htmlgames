<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mage Quest: Elemental Powers</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* UI Layer */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
            color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; box-sizing: border-box;
        }
        .hud-box { background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #444; }

        /* Canvas */
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }

        /* Notification */
        #msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #ffd700; font-size: 24px; font-weight: bold; text-shadow: 0 2px 4px #000;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; text-align: center; width: 100%;
        }

        /* Controls */
        #controls {
            position: absolute; bottom: 20px; width: 100%; height: 180px;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 20;
        }
        .dpad { position: relative; width: 140px; height: 140px; pointer-events: auto; }
        
        .btn {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white; cursor: pointer; backdrop-filter: blur(4px);
        }
        .btn:active, .btn.pressed { background: rgba(255,255,255,0.4); transform: scale(0.95); border-color: white; }
        
        .up { top: 0; left: 45px; } .down { bottom: 0; left: 45px; }
        .left { top: 45px; left: 0; } .right { top: 45px; right: 0; }

        #dashBtn {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 80px; height: 80px; border-radius: 50%; background: #e03e3e;
            border: 4px solid #8a1c1c; pointer-events: auto; color: white; font-weight: bold;
            display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px #e03e3e;
        }
        #dashBtn:active, #dashBtn.pressed { background: #ff6666; transform: translateX(-50%) scale(0.95); }
    </style>
</head>
<body>

<div id="ui">
    <div class="hud-box">
        <div id="hpTxt">‚ù§Ô∏è 100</div>
        <div id="xpTxt" style="color:#ffd700; font-size: 0.9em;">‚≠ê Lvl 1</div>
    </div>
    <div class="hud-box" style="text-align: right;">
        <div id="spellTxt" style="color:#0ff">‚ú® Bolt</div>
        <div id="floorTxt" style="color:#aaa; font-size: 0.9em;">Floor 1</div>
    </div>
</div>

<div id="msg"></div>
<canvas id="game"></canvas>

<div id="controls">
    <div class="dpad">
        <div class="btn up" data-k="w">‚¨ÜÔ∏è</div><div class="btn down" data-k="s">‚¨áÔ∏è</div>
        <div class="btn left" data-k="a">‚¨ÖÔ∏è</div><div class="btn right" data-k="d">‚û°Ô∏è</div>
    </div>
    <div id="dashBtn" data-k=" ">DASH</div>
    <div class="dpad">
        <div class="btn up" data-k="ArrowUp">üî•</div><div class="btn down" data-k="ArrowDown">üî•</div>
        <div class="btn left" data-k="ArrowLeft">üî•</div><div class="btn right" data-k="ArrowRight">üî•</div>
    </div>
</div>

<script>
// --- SPELL DEFINITIONS ---
const TILE = 48;
const MOBS_GFX = ['üëæ', 'üëπ', 'üë∫', 'üíÄ', 'üëø']; 
const SPELLS = {
    bolt:   { name: "Bolt",   icon: "‚ú®", color: "#aaf", dmg: 12, speed: 0.30, effect: 'knockback' },
    fire:   { name: "Fire",   icon: "üî•", color: "#f40", dmg: 15, speed: 0.25, effect: 'burn' },
    ice:    { name: "Ice",    icon: "‚ùÑÔ∏è", color: "#0ff", dmg: 10, speed: 0.35, effect: 'freeze' },
    poison: { name: "Venom",  icon: "ü§¢", color: "#0f0", dmg: 5,  speed: 0.20, effect: 'poison' }
};

// --- GAME ENGINE ---
const C = document.getElementById('game');
const X = C.getContext('2d');
let W, H;

const STATE = {
    map: [], size: 20, floor: 1,
    cam: {x:0, y:0},
    keys: {},
    p: { x:1, y:1, rx:1, ry:1, hp:100, maxHp:100, xp:0, lvl:1, nextXp:100, dash:0, cool:0, moving:false, spell:{...SPELLS.bolt, lvl:1, id:'bolt'} },
    mobs: [], shots: [], loot: [], parts: [], pops: [],
    exit: {x:0, y:0, open:false}
};

// --- INPUT & INIT ---
const resize = () => { W=C.width=window.innerWidth; H=C.height=window.innerHeight; };
window.addEventListener('resize', resize);
window.onkeydown = e => STATE.keys[e.key] = true;
window.onkeyup = e => STATE.keys[e.key] = false;

document.querySelectorAll('[data-k]').forEach(el => {
    const k = el.dataset.k;
    const press = (e) => { e.preventDefault(); STATE.keys[k]=true; el.classList.add('pressed'); };
    const release = (e) => { e.preventDefault(); STATE.keys[k]=false; el.classList.remove('pressed'); };
    el.addEventListener('pointerdown', press);
    el.addEventListener('pointerup', release);
    el.addEventListener('pointerleave', release);
});

function init() { resize(); genLevel(); loop(); }
function loop() { update(); draw(); requestAnimationFrame(loop); }

// --- UPDATE LOGIC ---
function update() {
    const P = STATE.p;

    // 1. Movement
    let dx=0, dy=0;
    if(STATE.keys.w) dy=-1; if(STATE.keys.s) dy=1; if(STATE.keys.a) dx=-1; if(STATE.keys.d) dx=1;

    if((dx||dy) && !P.moving) {
        let nx=P.x+dx, ny=P.y+dy;
        if(!isWall(nx,ny)) {
            // Diagonal Check
            if(dx!==0 && dy!==0 && isWall(P.x, ny) && isWall(nx, P.y)) {} // Blocked
            else { P.x=nx; P.y=ny; P.moving=true; if(nx===STATE.exit.x && ny===STATE.exit.y && STATE.exit.open) nextLevel(); }
        }
    }
    // Snappy Lerp
    P.rx += (P.x - P.rx) * 0.5; P.ry += (P.y - P.ry) * 0.5;
    if(Math.abs(P.x-P.rx)<0.01 && Math.abs(P.y-P.ry)<0.01) P.moving=false;
    
    // Camera
    STATE.cam.x += ((P.rx*TILE-W/2) - STATE.cam.x) * 0.1;
    STATE.cam.y += ((P.ry*TILE-H/2) - STATE.cam.y) * 0.1;

    // 2. Dash
    if(P.dash>0) P.dash--;
    if(STATE.keys[' '] && P.dash<=0) {
        let ddx = dx||(Math.random()>0.5?1:-1), ddy=dy||0;
        let tx = P.x+ddx*2, ty=P.y+ddy*2;
        if(!isWall(tx,ty)) {
            P.x=tx; P.y=ty; P.rx=tx; P.ry=ty; P.dash=50; P.moving=false;
            addPop(P.rx, P.ry, "DASH!", "cyan");
            for(let i=0;i<8;i++) addPart(P.rx, P.ry, "white", -ddx*4, -ddy*4);
        }
    }

    // 3. Firing
    if(P.cool>0) P.cool--;
    if(P.cool<=0) {
        let sx=0, sy=0;
        if(STATE.keys.ArrowUp) sy=-1; else if(STATE.keys.ArrowDown) sy=1; else if(STATE.keys.ArrowLeft) sx=-1; else if(STATE.keys.ArrowRight) sx=1;
        if(sx||sy) {
            let dmg = (P.spell.dmg + P.lvl*2) * (1+P.spell.lvl*0.2);
            STATE.shots.push({
                x: P.rx, y: P.ry, vx: sx*P.spell.speed, vy: sy*P.spell.speed,
                life: 60, spell: P.spell, dmg: dmg
            });
            P.cool=12;
        }
    }

    // 4. Projectiles
    for(let i=STATE.shots.length-1; i>=0; i--) {
        let s = STATE.shots[i];
        s.x+=s.vx; s.y+=s.vy; s.life--;
        if(isWall(Math.round(s.x), Math.round(s.y))) { addPart(s.x, s.y, s.spell.color); STATE.shots.splice(i,1); continue; }
        
        let hit=false;
        for(let m of STATE.mobs) {
            if(Math.hypot(m.x-s.x, m.y-s.y)<0.7) {
                // Apply Damage
                m.hp -= s.dmg;
                addPop(m.x, m.y, Math.floor(s.dmg), "white");
                
                // --- APPLY SPELL EFFECTS ---
                if(s.spell.effect === 'burn') {
                    m.status.burn = 120; // 2 seconds
                    addPop(m.x, m.y - 0.5, "BURN!", "orange");
                }
                if(s.spell.effect === 'freeze') {
                    m.status.freeze = 180; // 3 seconds
                    addPop(m.x, m.y - 0.5, "FREEZE!", "cyan");
                }
                if(s.spell.effect === 'poison') {
                    m.status.poison = 300; // 5 seconds
                    addPop(m.x, m.y - 0.5, "POISON!", "lime");
                }
                if(s.spell.effect === 'knockback') {
                    // Push back opposite to player direction
                    let knx = m.x + (s.vx > 0 ? 1 : s.vx < 0 ? -1 : 0);
                    let kny = m.y + (s.vy > 0 ? 1 : s.vy < 0 ? -1 : 0);
                    if(!isWall(Math.round(knx), Math.round(kny))) {
                        m.x = knx; m.y = kny; // Instant Knockback
                    }
                    addPop(m.x, m.y - 0.5, "PUSH!", "white");
                }

                if(m.hp<=0) killMob(m);
                hit=true; break;
            }
        }
        if(hit) { STATE.shots.splice(i,1); continue; }
        if(s.life<=0) STATE.shots.splice(i,1);
        else if(s.life%4===0) addPart(s.x, s.y, s.spell.color, 0, 0, 2);
    }

    // 5. Mobs Logic
    STATE.mobs.forEach(m => {
        // --- PROCESS STATUS EFFECTS ---
        let moveSpeed = 0.035; // Default Speed
        
        // Burn: Damage over time
        if(m.status.burn > 0) {
            m.status.burn--;
            if(m.status.burn % 30 === 0) {
                m.hp -= 5;
                addPop(m.x, m.y, "5", "orange");
                addPart(m.x, m.y, "orange");
            }
            if(m.hp<=0) killMob(m);
        }

        // Freeze: Slow Down
        if(m.status.freeze > 0) {
            m.status.freeze--;
            moveSpeed = 0.005; // 85% Slower
            if(Math.random()<0.1) addPart(m.x, m.y, "cyan");
        }

        // Poison: Long duration low damage
        if(m.status.poison > 0) {
            m.status.poison--;
            if(m.status.poison % 60 === 0) {
                m.hp -= 3;
                addPop(m.x, m.y, "3", "lime");
            }
            if(m.hp<=0) killMob(m);
        }

        // Movement
        let dist = Math.hypot(P.x-m.x, P.y-m.y);
        if(dist < 8) {
            let mx = (P.x-m.x) * moveSpeed;
            let my = (P.y-m.y) * moveSpeed;
            if(!isWall(Math.round(m.x+mx), Math.round(m.y+my))) {
                m.x += mx; m.y += my;
            }
        }
        // Attack Player
        if(dist < 0.6) {
            P.hp -= 0.5;
            if(Math.random()<0.05) addPop(P.rx, P.ry, "-1", "red");
            if(P.hp<=0) location.reload();
        }
    });

    // Merge (optimized)
    for(let i=0; i<STATE.mobs.length; i++) {
        for(let j=i+1; j<STATE.mobs.length; j++) {
            let m1=STATE.mobs[i], m2=STATE.mobs[j];
            if(Math.hypot(m1.x-m2.x, m1.y-m2.y)<0.5) {
                m1.hp+=m2.hp; m1.maxHp+=m2.maxHp; m1.tier=Math.min(4, m1.tier+1); m1.scale+=0.2;
                addPop(m1.x, m1.y, "MERGE!", "violet");
                STATE.mobs.splice(j,1);
            }
        }
    }

    // Loot
    for(let i=STATE.loot.length-1; i>=0; i--) {
        let l=STATE.loot[i];
        if(Math.hypot(P.rx-l.x, P.ry-l.y)<0.8) {
            if(l.type==='spell') {
                if(P.spell.id===l.id) { P.spell.lvl++; notify(`Upgraded ${P.spell.name}!`); }
                else { P.spell={...SPELLS[l.id], lvl:1, id:l.id}; notify(`Found: ${P.spell.name}`); }
                addPop(P.rx, P.ry, "SPELL!", l.color);
            } else {
                P.hp=Math.min(P.maxHp, P.hp+30); addPop(P.rx, P.ry, "+30 HP", "lime");
            }
            STATE.loot.splice(i,1);
        }
    }
    // XP
    if(P.xp >= P.nextXp) {
        P.lvl++; P.xp-=P.nextXp; P.nextXp=Math.floor(P.nextXp*1.5); P.maxHp+=20; P.hp=P.maxHp;
        addPop(P.rx, P.ry, "LEVEL UP!", "gold");
    }

    // VFX
    STATE.parts.forEach((p,i)=>{p.x+=p.vx; p.y+=p.vy; p.life-=0.1; if(p.life<=0) STATE.parts.splice(i,1);});
    STATE.pops.forEach((p,i)=>{p.y-=0.02; p.life--; if(p.life<=0) STATE.pops.splice(i,1);});

    // UI
    document.getElementById('hpTxt').innerText = `‚ù§Ô∏è ${Math.floor(P.hp)}/${P.maxHp}`;
    document.getElementById('xpTxt').innerText = `‚≠ê Lvl ${P.lvl}`;
    document.getElementById('spellTxt').innerText = `${P.spell.icon} ${P.spell.name} (${P.spell.lvl})`;
    document.getElementById('floorTxt').innerText = `Floor ${STATE.floor}`;
}

// --- DRAW ---
function draw() {
    X.fillStyle = "#080808"; X.fillRect(0,0,W,H);
    X.save(); X.translate(-STATE.cam.x, -STATE.cam.y); X.textAlign="center"; X.textBaseline="middle";

    let cx=Math.floor(STATE.cam.x/TILE), cy=Math.floor(STATE.cam.y/TILE);
    for(let y=cy; y<cy+H/TILE+1; y++) for(let x=cx; x<cx+W/TILE+1; x++) {
        if(isWall(x,y)) { X.fillStyle="#222"; X.fillRect(x*TILE,y*TILE,TILE,TILE); X.fillStyle="#111"; X.fillRect(x*TILE,y*TILE+TILE-8,TILE,8); }
        else { X.strokeStyle="#1a1a1a"; X.strokeRect(x*TILE,y*TILE,TILE,TILE); }
    }

    STATE.loot.forEach(l=>{ let b=Math.sin(Date.now()/300)*5; X.font="28px serif"; X.fillText(l.icon, l.x*TILE+24, l.y*TILE+24+b); });
    X.font="32px serif"; X.fillText(STATE.exit.open?"üåÄ":"üîí", STATE.exit.x*TILE+24, STATE.exit.y*TILE+24);

    STATE.mobs.forEach(m => {
        let size=TILE*(0.8+m.scale*0.2); X.font=`${size}px serif`;
        // Color tint via status
        if(m.status.freeze>0) X.fillStyle = "cyan";
        else if(m.status.poison>0) X.fillStyle = "lime";
        else if(m.status.burn>0) X.fillStyle = "orange";
        else X.fillStyle = "white"; // Default text color doesn't matter much for emojis, but good for debug
        
        X.fillText(MOBS_GFX[m.tier]||"üëæ", m.x*TILE+24, m.y*TILE+24);
        X.fillStyle="red"; X.fillRect(m.x*TILE, m.y*TILE-10, TILE, 4);
        X.fillStyle="lime"; X.fillRect(m.x*TILE, m.y*TILE-10, TILE*(m.hp/m.maxHp), 4);
        
        // Status Icons
        let st = "";
        if(m.status.burn>0) st+="üî•";
        if(m.status.freeze>0) st+="‚ùÑÔ∏è";
        if(m.status.poison>0) st+="ü§¢";
        if(st) { X.font="12px serif"; X.fillText(st, m.x*TILE+24, m.y*TILE-20); }
    });

    X.font="32px serif"; X.fillText("üßô‚Äç‚ôÇÔ∏è", STATE.p.rx*TILE+24, STATE.p.ry*TILE+24);
    STATE.shots.forEach(s => { X.font="20px serif"; X.fillText(s.spell.icon, s.x*TILE+24, s.y*TILE+24); });
    STATE.parts.forEach(p => { X.fillStyle=p.c; X.globalAlpha=p.life; X.beginPath(); X.arc(p.x*TILE+24, p.y*TILE+24, p.r, 0, Math.PI*2); X.fill(); });
    X.globalAlpha=1;
    STATE.pops.forEach(p => { X.fillStyle=p.c; X.font="bold 16px sans-serif"; X.fillText(p.t, p.x*TILE+24, p.y*TILE+24); });

    X.restore();
}

// --- GEN ---
function genLevel() {
    STATE.size=15+STATE.floor*5; let m=[];
    for(let y=0;y<STATE.size;y++){let r=[];for(let x=0;x<STATE.size;x++)r.push(Math.random()<0.45||x==0||y==0||x==STATE.size-1||y==STATE.size-1?1:0);m.push(r);}
    for(let i=0;i<4;i++){let nm=JSON.parse(JSON.stringify(m));for(let y=1;y<STATE.size-1;y++)for(let x=1;x<STATE.size-1;x++){let n=0;for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++)if(m[y+dy][x+dx])n++;if(n>=5)nm[y][x]=1;else if(n<=3)nm[y][x]=0;}m=nm;}
    for(let y=1;y<STATE.size-1;y++)for(let x=1;x<STATE.size-1;x++)if(!m[y][x]&&!m[y+1][x+1]&&m[y][x+1]&&m[y+1][x])m[y][x+1]=0;
    
    let start=null;for(let y=1;y<STATE.size-1;y++)for(let x=1;x<STATE.size-1;x++)if(!m[y][x]){start={x,y};break;}
    if(!start)return genLevel();
    let v=new Set(),q=[start];v.add(`${start.x},${start.y}`);
    while(q.length){let c=q.pop();[[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy])=>{let nx=c.x+dx,ny=c.y+dy;if(!m[ny][nx]&&!v.has(`${nx},${ny}`)){v.add(`${nx},${ny}`);q.push({x:nx,y:ny});}});}
    for(let y=1;y<STATE.size-1;y++)for(let x=1;x<STATE.size-1;x++)if(!m[y][x]&&!v.has(`${x},${y}`)){let cx=x,cy=y;while(m[cy][cx]||!v.has(`${cx},${cy}`)){m[cy][cx]=0;if(cx<start.x)cx++;else if(cx>start.x)cx--;if(cy<start.y)cy++;else if(cy>start.y)cy--;}}
    STATE.map=m; STATE.p.x=start.x; STATE.p.y=start.y; STATE.p.rx=start.x; STATE.p.ry=start.y;
    
    STATE.loot=[]; STATE.mobs=[];
    const rnd=()=>{let x,y;do{x=Math.floor(Math.random()*STATE.size);y=Math.floor(Math.random()*STATE.size);}while(m[y][x]);return{x,y};};
    for(let i=0;i<4;i++){let p=rnd(),sp=Math.random()>0.5,ks=Object.keys(SPELLS),id=ks[Math.floor(Math.random()*ks.length)];STATE.loot.push({x:p.x,y:p.y,type:sp?'spell':'heal',id:id,icon:sp?'üìú':'üç∑',color:sp?SPELLS[id].color:'red'});}
    for(let i=0;i<3+STATE.floor;i++){
        let p=rnd();
        if(Math.hypot(p.x-start.x,p.y-start.y)>6) 
            // Initialize status effects here
            STATE.mobs.push({x:p.x,y:p.y,hp:20+STATE.floor*5,maxHp:20+STATE.floor*5,scale:1,tier:0, status:{burn:0, freeze:0, poison:0}});
    }
    let ex=rnd(); STATE.exit={...ex,open:false}; notify(`Floor ${STATE.floor}`);
}

function isWall(x,y){return x<0||y<0||x>=STATE.size||y>=STATE.size||STATE.map[y][x];}
function addPart(x,y,c,vx=0,vy=0,r=4){STATE.parts.push({x,y,c,vx:(Math.random()-0.5)+vx,vy:(Math.random()-0.5)+vy,life:1,r});}
function addPop(x,y,t,c){STATE.pops.push({x,y,t,c,life:60});}
function notify(m){let e=document.getElementById('msg');e.innerText=m;e.style.opacity=1;setTimeout(()=>e.style.opacity=0,2000);}
function killMob(m){STATE.mobs=STATE.mobs.filter(e=>e!==m);STATE.p.xp+=20;addPop(m.x,m.y,"+20 XP","gold");if(STATE.mobs.length==0){STATE.exit.open=true;notify("Exit Open!");}}
function nextLevel(){STATE.floor++;genLevel();}

init();
</script>
</body>
</html>
