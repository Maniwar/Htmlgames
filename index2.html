<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mage Quest: The Complete Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
            display: flex; justify-content: space-between; pointer-events: none;
            color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; z-index: 10;
        }
        canvas { display: block; image-rendering: pixelated; }
        
        /* Mobile Controls */
        #controls {
            position: absolute; bottom: 20px; width: 100%; height: 180px;
            pointer-events: none; display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box;
        }
        .dpad { position: relative; width: 140px; height: 140px; pointer-events: auto; }
        .btn {
            position: absolute; width: 45px; height: 45px;
            background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: white; display: flex; justify-content: center; align-items: center; font-size: 20px;
        }
        .btn:active { background: rgba(255,255,255,0.5); transform: scale(0.9); }
        .up { top: 0; left: 47px; } .down { bottom: 0; left: 47px; }
        .left { top: 47px; left: 0; } .right { top: 47px; right: 0; }
        
        #dashBtn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 80px; height: 80px; border-radius: 50%; background: rgba(255, 100, 100, 0.5);
            border: 4px solid rgba(255, 100, 100, 0.8); pointer-events: auto;
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
        }
        #dashBtn:active { background: red; }
        
        /* Notifications */
        #notif {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            color: cyan; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px blue;
            opacity: 0; transition: opacity 0.5s; pointer-events: none; text-align: center;
        }
    </style>
</head>
<body>

<div id="ui">
    <div>‚ù§Ô∏è <span id="hp">100</span> | üõ°Ô∏è <span id="lvl">1</span></div>
    <div>‚ú® <span id="spell">Basic</span> | üìú <span id="xp">0</span></div>
</div>
<div id="notif">Level Up!</div>
<canvas id="game"></canvas>

<div id="controls">
    <div class="dpad" id="movePad">
        <div class="btn up" data-k="w">‚¨ÜÔ∏è</div><div class="btn down" data-k="s">‚¨áÔ∏è</div>
        <div class="btn left" data-k="a">‚¨ÖÔ∏è</div><div class="btn right" data-k="d">‚û°Ô∏è</div>
    </div>
    <div id="dashBtn">DASH</div>
    <div class="dpad" id="firePad">
        <div class="btn up" data-k="ArrowUp">üî•</div><div class="btn down" data-k="ArrowDown">üî•</div>
        <div class="btn left" data-k="ArrowLeft">üî•</div><div class="btn right" data-k="ArrowRight">üî•</div>
    </div>
</div>

<script>
const C = document.getElementById('game');
const X = C.getContext('2d');
const TILE = 48; // Tile size
let W, H;

const STATE = {
    map: [], size: 30, stage: 1,
    cam: { x:0, y:0 },
    keys: {},
    particles: [],
    mobs: [],
    loot: [],
    shots: [],
    popups: [],
    exit: {x:0, y:0, open:false}
};

const PL = {
    x: 1, y: 1, // Logical grid pos
    rx: 1, ry: 1, // Render pos (smooth)
    hp: 100, maxHp: 100,
    xp: 0, lvl: 1,
    dash: 0, 
    spell: { name: "Magic Bolt", color: "#aaf", dmg: 10, type: "basic" }
};

// --- INPUT HANDLING ---
window.onkeydown = e => STATE.keys[e.key] = true;
window.onkeyup = e => STATE.keys[e.key] = false;
window.onresize = resize;

function resize() {
    W = C.width = window.innerWidth;
    H = C.height = window.innerHeight;
}

// --- MAIN LOOP ---
function init() {
    resize();
    genLevel();
    loop();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    // 1. Player Movement & Smoothing
    let dx = 0, dy = 0;
    if (STATE.keys.w) dy = -1;
    if (STATE.keys.s) dy = 1;
    if (STATE.keys.a) dx = -1;
    if (STATE.keys.d) dx = 1;

    // Movement Logic
    if ((dx || dy) && !PL.moving) {
        let nx = PL.x + dx, ny = PL.y + dy;
        if (!isWall(nx, ny)) {
            PL.x = nx; PL.y = ny;
            PL.moving = true;
            // Check exit
            if (nx === STATE.exit.x && ny === STATE.exit.y && STATE.exit.open) nextStage();
        }
    }

    // Smooth Lerp (Visuals catch up to logic)
    PL.rx += (PL.x - PL.rx) * 0.2;
    PL.ry += (PL.y - PL.ry) * 0.2;
    if (Math.abs(PL.x - PL.rx) < 0.05) PL.moving = false;

    // Camera Follow
    STATE.cam.x += ((PL.rx * TILE - W/2) - STATE.cam.x) * 0.1;
    STATE.cam.y += ((PL.ry * TILE - H/2) - STATE.cam.y) * 0.1;

    // 2. Dash Logic
    if (PL.dash > 0) PL.dash--;
    if (STATE.keys[' '] && PL.dash <= 0) {
        // Dash Direction is based on last move or default forward
        let ddx = dx || (Math.random() > 0.5 ? 1 : -1); 
        let ddy = dy || 0;
        
        // Attempt long jump (2 tiles)
        let tx = PL.x + ddx * 2;
        let ty = PL.y + ddy * 2;
        
        if (!isWall(tx, ty)) {
            PL.x = tx; PL.y = ty;
            PL.rx = tx; PL.ry = ty; // Snap visual
            PL.dash = 60; // Cooldown
            addPopup(PL.rx, PL.ry, "DASH!", "cyan");
            
            // DIRECTIONAL PARTICLES: Emit opposite to movement
            for(let i=0; i<15; i++) {
                // Particles trail BEHIND the player
                addPart(PL.rx * TILE + 24, PL.ry * TILE + 24, "white", -ddx * 4, -ddy * 4);
            }
        }
    }

    // 3. Shooting
    if (PL.cool > 0) PL.cool--;
    if (PL.cool <= 0) {
        let sx=0, sy=0;
        if (STATE.keys.ArrowUp) sy = -1;
        else if (STATE.keys.ArrowDown) sy = 1;
        else if (STATE.keys.ArrowLeft) sx = -1;
        else if (STATE.keys.ArrowRight) sx = 1;

        if (sx || sy) {
            STATE.shots.push({ x: PL.rx, y: PL.ry, vx: sx*0.3, vy: sy*0.3, life: 60, spell: PL.spell });
            PL.cool = 15;
        }
    }

    // 4. Projectiles
    STATE.shots.forEach((s, i) => {
        s.x += s.vx; s.y += s.vy;
        s.life--;
        addPart(s.x*TILE+24, s.y*TILE+24, s.spell.color, -s.vx*5, -s.vy*5, 0.5); // Trail

        // Wall Hit
        if (isWall(Math.round(s.x), Math.round(s.y))) s.life = 0;

        // Enemy Hit
        STATE.mobs.forEach(m => {
            if (Math.hypot(m.x - s.x, m.y - s.y) < 0.6) {
                m.hp -= s.spell.dmg;
                s.life = 0;
                addPopup(m.x, m.y, s.spell.dmg, "orange");
                if (m.hp <= 0) killMob(m);
            }
        });

        if (s.life <= 0) STATE.shots.splice(i, 1);
    });

    // 5. Mobs Logic & MERGING
    STATE.mobs.forEach((m, i) => {
        // Simple Chase
        let dis = Math.hypot(PL.x - m.x, PL.y - m.y);
        if (dis < 8) {
            m.x += (PL.x - m.x) * 0.03;
            m.y += (PL.y - m.y) * 0.03;
        }

        // Damage Player
        if (dis < 0.5) {
            PL.hp -= 0.5;
            if(Math.random()<0.1) addPopup(PL.rx, PL.ry, "-1", "red");
            if(PL.hp <= 0) location.reload(); 
        }

        // MERGING LOGIC: Check collisions with other mobs
        for (let j = i + 1; j < STATE.mobs.length; j++) {
            let other = STATE.mobs[j];
            if (Math.hypot(m.x - other.x, m.y - other.y) < 0.5 && !m.merged && !other.merged) {
                // MERGE!
                m.hp += other.hp;
                m.maxHp += other.maxHp;
                m.scale = (m.scale || 1) + 0.5; // Grow bigger
                m.color = "purple"; // Change color
                addPopup(m.x, m.y, "MERGE!", "magenta");
                
                STATE.mobs.splice(j, 1); // Remove other
                m.merged = true; // Cooldown flag
                setTimeout(() => m.merged = false, 2000);
            }
        }
    });

    // 6. Loot Pickup & SPELL MIXING
    STATE.loot.forEach((l, i) => {
        if (Math.hypot(PL.rx - l.x, PL.ry - l.y) < 0.8) {
            if (l.type === 'spell') {
                mixSpell(l.variant);
            } else if (l.type === 'heal') {
                PL.hp = Math.min(PL.maxHp, PL.hp + 20);
                addPopup(PL.rx, PL.ry, "+20 HP", "lime");
            }
            STATE.loot.splice(i, 1);
        }
    });

    // Particles
    STATE.particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        if (p.life <= 0) STATE.particles.splice(i, 1);
    });
    
    // UI Updates
    document.getElementById('hp').innerText = Math.floor(PL.hp);
    document.getElementById('spell').innerText = PL.spell.name;
}

// --- SPELL MIXING SYSTEM ---
function mixSpell(newType) {
    let current = PL.spell.type;
    
    // Logic: Combine types
    if (current === 'basic') {
        if (newType === 'fire') setSpell('Fireball', 'orange', 15, 'fire');
        if (newType === 'ice') setSpell('Ice Shard', 'cyan', 12, 'ice');
    } 
    else if (current === 'fire') {
        if (newType === 'ice') setSpell('Frostfire', 'violet', 25, 'hybrid'); // MIX!
        else setSpell('Inferno', 'red', 20, 'fire'); // Upgrade
    }
    else if (current === 'ice') {
        if (newType === 'fire') setSpell('Frostfire', 'violet', 25, 'hybrid'); // MIX!
        else setSpell('Blizzard', 'blue', 18, 'ice'); // Upgrade
    }
    else if (current === 'hybrid') {
        setSpell('Omega Beam', 'white', 50, 'god'); // MAX LEVEL
    }
    
    addPopup(PL.rx, PL.ry, "SPELL MIX!", "gold");
    notify(`Equipped: ${PL.spell.name}`);
}

function setSpell(name, color, dmg, type) {
    PL.spell = { name, color, dmg, type };
}

// --- DRAWING ---
function draw() {
    // Clear
    X.fillStyle = "#111";
    X.fillRect(0, 0, W, H);

    X.save();
    X.translate(-STATE.cam.x, -STATE.cam.y);

    // Map (Optimized)
    let cx = Math.floor(STATE.cam.x / TILE);
    let cy = Math.floor(STATE.cam.y / TILE);
    for (let y = cy; y < cy + H/TILE + 1; y++) {
        for (let x = cx; x < cx + W/TILE + 1; x++) {
            if (isWall(x, y)) {
                X.fillStyle = "#444";
                X.fillRect(x*TILE, y*TILE, TILE, TILE);
                X.fillStyle = "#222"; // Shadow
                X.fillRect(x*TILE, y*TILE+40, TILE, 8);
            } else {
                X.strokeStyle = "#222";
                X.strokeRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
    }

    // Exit
    if (STATE.exit.open) {
        X.font = "40px serif";
        X.fillText("üåÄ", STATE.exit.x*TILE + 4, STATE.exit.y*TILE + 36);
    }

    // Loot
    STATE.loot.forEach(l => {
        X.font = "30px serif";
        X.fillText(l.icon, l.x*TILE+10, l.y*TILE+35);
    });

    // Mobs
    STATE.mobs.forEach(m => {
        let s = (m.scale || 1) * TILE;
        X.fillStyle = m.color || "red";
        X.fillRect(m.x*TILE - s/2 + 24, m.y*TILE - s/2 + 24, s, s);
        // HP Bar
        X.fillStyle = "lime";
        X.fillRect(m.x*TILE, m.y*TILE - 10, TILE * (m.hp/m.maxHp), 4);
    });

    // Player
    X.font = "40px serif";
    X.fillText("üßô‚Äç‚ôÇÔ∏è", PL.rx*TILE + 4, PL.ry*TILE + 36);

    // Particles
    STATE.particles.forEach(p => {
        X.fillStyle = p.color;
        X.globalAlpha = p.life;
        X.beginPath();
        X.arc(p.x, p.y, p.r || 4, 0, Math.PI*2);
        X.fill();
    });
    X.globalAlpha = 1;

    // Popups
    STATE.popups.forEach((p, i) => {
        p.life--;
        p.y -= 0.05;
        X.fillStyle = p.c;
        X.font = "bold 20px sans-serif";
        X.fillText(p.t, p.x*TILE, p.y*TILE);
        if(p.life <= 0) STATE.popups.splice(i,1);
    });

    X.restore();
}

// --- GENERATION (GUARANTEED CONNECTED) ---
function genLevel() {
    STATE.size = 20 + STATE.stage * 5;
    let m = [];
    
    // 1. Random Noise
    for(let y=0; y<STATE.size; y++) {
        let row = [];
        for(let x=0; x<STATE.size; x++) {
            if (x===0 || y===0 || x===STATE.size-1 || y===STATE.size-1) row.push(1);
            else row.push(Math.random() > 0.4 ? 1 : 0);
        }
        m.push(row);
    }

    // 2. Cellular Automata (Smooth)
    for(let i=0; i<5; i++) {
        let nm = JSON.parse(JSON.stringify(m));
        for(let y=1; y<STATE.size-1; y++) for(let x=1; x<STATE.size-1; x++) {
            let n = 0;
            for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) if(m[y+dy][x+dx]) n++;
            if(n >= 5) nm[y][x] = 1; else if(n <= 3) nm[y][x] = 0;
        }
        m = nm;
    }
    STATE.map = m;

    // 3. GUARANTEED CONNECTIVITY (Tunneling)
    // Find first floor tile
    let start = null;
    for(let y=1; y<STATE.size-1; y++) for(let x=1; x<STATE.size-1; x++) {
        if(!m[y][x]) { start = {x,y}; break; }
    }
    if(!start) return genLevel(); // Retry if solid rock

    // Flood fill to find all reachable
    let reachable = new Set();
    let q = [start];
    reachable.add(`${start.x},${start.y}`);
    
    while(q.length) {
        let c = q.pop();
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
            let nx = c.x+dx, ny = c.y+dy;
            if(!m[ny][nx] && !reachable.has(`${nx},${ny}`)) {
                reachable.add(`${nx},${ny}`);
                q.push({x:nx, y:ny});
            }
        });
    }

    // Check for islands and tunnel to them
    for(let y=1; y<STATE.size-1; y++) for(let x=1; x<STATE.size-1; x++) {
        if(!m[y][x] && !reachable.has(`${x},${y}`)) {
            // Found an island! Dig a tunnel to nearest reachable point
            // (Simplified: Just blast a line to start)
            let cur = {x,y};
            while(m[cur.y][cur.x] !== 0 || !reachable.has(`${cur.x},${cur.y}`)) {
                m[cur.y][cur.x] = 0; // Dig
                if(cur.x < start.x) cur.x++;
                else if(cur.x > start.x) cur.x--;
                if(cur.y < start.y) cur.y++;
                else if(cur.y > start.y) cur.y--;
            }
        }
    }

    // 4. Place Entities
    PL.x = start.x; PL.y = start.y; PL.rx = start.x; PL.ry = start.y;
    
    // Exit
    let ex;
    do { ex = {x: rInt(STATE.size), y: rInt(STATE.size)}; } while(m[ex.y][ex.x]);
    STATE.exit = { ...ex, open: false };

    // Mobs
    STATE.mobs = [];
    for(let i=0; i<5+STATE.stage; i++) {
        let mx, my;
        do { mx=rInt(STATE.size); my=rInt(STATE.size); } while(m[my][mx] || Math.hypot(mx-PL.x, my-PL.y)<5);
        STATE.mobs.push({ x:mx, y:my, hp:20+STATE.stage*5, maxHp:20+STATE.stage*5 });
    }

    // Loot
    STATE.loot = [];
    for(let i=0; i<4; i++) {
        let lx, ly;
        do { lx=rInt(STATE.size); ly=rInt(STATE.size); } while(m[ly][lx]);
        let isSpell = Math.random() > 0.5;
        STATE.loot.push({ 
            x:lx, y:ly, 
            type: isSpell ? 'spell' : 'heal',
            variant: Math.random()>0.5 ? 'fire' : 'ice',
            icon: isSpell ? 'üìú' : 'üç∑'
        });
    }

    notify(`Stage ${STATE.stage}`);
}

// --- UTILS ---
function isWall(x, y) {
    if(x<0 || y<0 || x>=STATE.size || y>=STATE.size) return true;
    return STATE.map[y][x];
}
function addPart(x, y, c, vx, vy, r) {
    STATE.particles.push({ x, y, c, vx: (Math.random()-0.5)*2 + vx, vy: (Math.random()-0.5)*2 + vy, life: 1, r });
}
function addPopup(x, y, t, c) { STATE.popups.push({x,y,t,c,life:1}); }
function killMob(m) {
    STATE.mobs = STATE.mobs.filter(e => e !== m);
    PL.xp += 10;
    if(STATE.mobs.length === 0) { STATE.exit.open = true; notify("Exit Open!"); }
}
function nextStage() { STATE.stage++; genLevel(); }
function notify(msg) {
    let el = document.getElementById('notif');
    el.innerText = msg; el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 2000);
}
function rInt(n) { return Math.floor(Math.random()*n); }

// Controls Logic
document.querySelectorAll('.btn').forEach(b => {
    b.onpointerdown = e => { STATE.keys[b.dataset.k] = true; b.style.background="rgba(255,255,255,0.5)"; e.preventDefault(); };
    b.onpointerup = e => { STATE.keys[b.dataset.k] = false; b.style.background=""; e.preventDefault(); };
    b.onpointerleave = e => { STATE.keys[b.dataset.k] = false; b.style.background=""; };
});
document.getElementById('dashBtn').onpointerdown = e => { STATE.keys[' '] = true; e.preventDefault(); };
document.getElementById('dashBtn').onpointerup = e => { STATE.keys[' '] = false; e.preventDefault(); };

init();
</script>
</body>
</html>
