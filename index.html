<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler - Mage Quest</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            transition: background-color 1s;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        #gameCanvas {
            border: 1px solid #000;
            display: block;
        }
        #controls, #quickAccessBar, #spellQuickBar {
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        .dpad {
            width: 30vw;
            height: 30vw;
            max-width: 120px;
            max-height: 120px;
            position: relative;
        }
        .dpad button {
            position: absolute;
            width: 8vw;
            height: 8vw;
            max-width: 32px;
            max-height: 32px;
            background: #ccc;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .up { top: 0; left: 50%; transform: translateX(-50%); }
        .left { top: 50%; left: 0; transform: translateY(-50%); }
        .right { top: 50%; right: 0; transform: translateY(-50%); }
        .down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #info {
            text-align: center;
            margin-bottom: 10px;
            font-family: Arial, sans-serif;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        #inventory {
            border: 1px solid gray;
            padding: 10px;
            display: none;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.8);
        }
        #inventoryList {
            list-style-type: none;
            padding: 0;
        }
        #inventoryList li {
            margin: 5px 0;
            cursor: move;
        }
        #inventoryList li button {
            margin-left: 10px;
        }
        #quickAccessBar, #spellQuickBar {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        .quickSlot, .spellSlot {
            position: relative;
            width: 50px;
            height: 50px;
            border: 2px solid #ccc;
            margin: 0 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eee;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        .quickSlot:hover, .spellSlot:hover {
            background-color: #ddd;
            transform: scale(1.1);
        }
        .spellSlot {
            background-color: #d1e7ff; /* Light blue for spells */
        }
        .spellSlot:hover {
            background-color: #b3d4ff;
        }
        .quickSlot.drag-reject, .spellSlot.drag-reject {
            border-color: red; /* Feedback for invalid drop */
        }
        .key {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 12px;
            color: #333;
        }
        .item {
            font-size: 24px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #notification {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">
            <span id="stage">Stage: 1</span> | 
            <span id="health">Health: 100/100</span> | 
            <span id="level">Level: 1</span> | 
            <span id="xp">XP: 0/100</span> | 
            <span id="equippedSpell">Spell: None</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="controls">
            <div id="movementDpad" class="dpad">
                <button class="up" id="moveUp">‚¨ÜÔ∏è</button>
                <button class="left" id="moveLeft">‚¨ÖÔ∏è</button>
                <button class="right" id="moveRight">‚û°Ô∏è</button>
                <button class="down" id="moveDown">‚¨áÔ∏è</button>
            </div>
            <div id="firingDpad" class="dpad">
                <button class="up" id="fireUp">‚ú®‚¨ÜÔ∏è</button>
                <button class="left" id="fireLeft">‚ú®‚¨ÖÔ∏è</button>
                <button class="right" id="fireRight">‚ú®‚û°Ô∏è</button>
                <button class="down" id="fireDown">‚ú®‚¨áÔ∏è</button>
            </div>
        </div>
        <button id="toggleInventory">Inventory</button>
        <div id="inventory">
            <h3>Equipped:</h3>
            <p id="inventoryEquippedSpell">Spell: None</p>
            <p id="equippedArmor">Armor: None</p>
            <h3>Inventory:</h3>
            <ul id="inventoryList"></ul>
        </div>
        <div id="quickAccessBar">
            <div class="quickSlot" data-slot="0"><span class="key">1</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="1"><span class="key">2</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="2"><span class="key">3</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="3"><span class="key">4</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="4"><span class="key">5</span><span class="item"></span></div>
        </div>
        <div id="spellQuickBar">
            <div class="spellSlot" data-slot="0"><span class="key">6</span><span class="item"></span></div>
            <div class="spellSlot" data-slot="1"><span class="key">7</span><span class="item"></span></div>
            <div class="spellSlot" data-slot="2"><span class="key">8</span><span class="item"></span></div>
        </div>
        <div id="notification"></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 40;
        const mapSize = 10;
        const logicalWidth = 400;
        const logicalHeight = 400;
        const directions = {
            up: { dx: 0, dy: -1 },
            left: { dx: -1, dy: 0 },
            right: { dx: 1, dy: 0 },
            down: { dx: 0, dy: 1 }
        };
        const MAX_ARROWS = 50;
        const MAX_PARTICLES = 500;
        const POISON_DAMAGE = 2;
        const POISON_INTERVAL = 1;
        const POISON_DURATION = 5;
        const BURN_DAMAGE = 5;
        const BURN_INTERVAL = 1;
        const SLOW_FACTOR = 0.5;
        const SLOW_DURATION = 3;
        const STUN_DURATION = 2;

        let hasEquippedSpell = false;

        function resizeCanvas() {
            const displaySize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.width = displaySize * pixelRatio;
            canvas.height = displaySize * pixelRatio;
            canvas.style.width = displaySize + 'px';
            canvas.style.height = displaySize + 'px';
            const scale = canvas.width / logicalWidth;
            ctx.setTransform(scale, 0, 0, scale, 0, 0);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let stage = 1;
        let player = {
            x: 1, y: 1, health: 100, maxHealth: 100, attack: 10, level: 1, xp: 0, xpToNext: 100,
            moveCooldown: 0, fireCooldown: 0, speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
            teleportTimer: 0, timeFreezeTimer: 0, invisibilityTimer: 0, doubleArrowTimer: 0,
            healthRegenTimer: 0, explosiveArrowsTimer: 0, slowTimer: 0, trail: [],
            equippedArmor: null, inventory: [],
            quickAccess: [null, null, null, null, null],
            spellQuickAccess: [null, null, null],
            charging: { up: false, left: false, right: false, down: false },
            chargeStartTime: { up: 0, left: 0, right: 0, down: 0 },
            critChance: 0.1,
            poisonTimer: 0,
            poisonAccumulator: 0,
            poisonParticleTimer: 0,
            combinedSpell: null
        };
        let currentMap = generateMap();
        let enemies = generateEnemies(stage);
        let loot = generateLoot();
        let arrows = [];
        let popups = [];
        let particles = [];
        let movingUp = false, movingLeft = false, movingRight = false, movingDown = false;
        let exitUnlocked = false;
        let lastTimestamp = 0;
        let hasDroppedThisStage = false;
        let pulseTime = 0;

        let countdownActive = false;
        let countdownTimer = 0;
        let countdownText = '';

        const tileSets = [
            { wall: 'üß±', floorColor: '#808080' },
            { wall: 'üå≥', floorColor: '#228B22' },
            { wall: 'üè∞', floorColor: '#A9A9A9' },
            { wall: 'ü™®', floorColor: '#EDC9AF' }
        ];
        let currentTileSet = tileSets[0];

        const spellColors = {
            'Magic Missile': 'blue',
            'Arcane Bolt': 'purple',
            'Scatter Spell': 'white',
            'Fireball': 'red',
            'Ice Shard': 'blue',
            'Lightning Bolt': 'yellow',
            'Earthquake': 'brown',
            'Disintegrate': 'green',
            'Arcane Barrage': 'cyan',
            'Triple Magic Missile': 'blue',
            'Triple Arcane Bolt': 'purple',
            'Triple Scatter Spell': 'white',
            'Triple Fireball': 'red',
            'Triple Ice Shard': 'blue',
            'Triple Lightning Bolt': 'yellow',
            'Triple Earthquake': 'brown',
            'Triple Disintegrate': 'green',
            'Triple Arcane Barrage': 'cyan',
            'Combined Spell': 'violet'
        };

        const rareSpells = [
            { type: 'spell', name: 'Magic Missile', attack: 15, fireRate: 0.5, symbol: '‚ú®', spread: false, isAoE: false, poisonChance: 0.1, description: 'A basic spell that fires a missile of magic energy.' },
            { type: 'spell', name: 'Arcane Bolt', attack: 20, fireRate: 0.3, symbol: 'üí´', spread: false, isAoE: false, description: 'A powerful bolt of arcane energy.' },
            { type: 'spell', name: 'Scatter Spell', attack: 10, fireRate: 0.7, symbol: 'üåü', spread: true, isAoE: false, description: 'Fires multiple projectiles in a spread pattern.' },
            { type: 'spell', name: 'Fireball', attack: 20, fireRate: 1.0, symbol: 'üî•', element: 'fire', effect: 'burn', spread: false, isAoE: false, description: 'Launches a fireball that burns enemies.' },
            { type: 'spell', name: 'Ice Shard', attack: 15, fireRate: 0.8, symbol: '‚ùÑÔ∏è', element: 'ice', effect: 'slow', spread: false, isAoE: false, description: 'Fires a shard of ice that slows enemies.' },
            { type: 'spell', name: 'Lightning Bolt', attack: 30, fireRate: 1.5, symbol: '‚ö°', element: 'lightning', effect: 'stun', spread: false, isAoE: false, description: 'Strikes with a bolt of lightning that can stun.' },
            { type: 'spell', name: 'Earthquake', attack: 25, fireRate: 2.0, symbol: 'üåã', element: 'earth', effect: 'aoe', spread: false, isAoE: true, description: 'Causes an earthquake that damages enemies in an area.' },
            { type: 'spell', name: 'Disintegrate', attack: 40, fireRate: 1.5, symbol: '‚òÑÔ∏è', spread: false, isAoE: false, description: 'A powerful spell that disintegrates enemies.' },
            { type: 'spell', name: 'Arcane Barrage', attack: 5, fireRate: 0.1, symbol: 'üå†', spread: false, isAoE: false, description: 'Fires a rapid barrage of arcane missiles.' }
        ];
        const rareArmor = [
            { type: 'armor', name: 'Leather Armor', defense: 5, symbol: 'üõ°Ô∏è', description: 'Light armor that provides basic protection.' },
            { type: 'armor', name: 'Chainmail', defense: 10, symbol: 'üõ°Ô∏è', description: 'Medium armor that offers better protection.' }
        ];
        const rarePotions = [
            { type: 'potion', name: 'Health Potion', effect: { health: 50 }, symbol: 'üß™', description: 'Restores 50 health points when consumed.' }
        ];

        const attackMultipliers = {
            normal: 1,
            strong: 1.5,
            veryStrong: 2,
            hyper: 3
        };

        const enemyAttackTypes = {
            grunt: { normal: 0.7, strong: 0.2, veryStrong: 0.1 },
            sniper: { normal: 0.5, strong: 0.3, veryStrong: 0.2 },
            tank: { normal: 0.4, strong: 0.3, veryStrong: 0.3 },
            summoner: { normal: 0.6, strong: 0.3, veryStrong: 0.1 },
            mage: { normal: 0.5, strong: 0.3, hyper: 0.2 }
        };

        function chooseAttackType(enemy) {
            const types = enemyAttackTypes[enemy.type];
            const rand = Math.random();
            let cumulative = 0;
            for (const [type, prob] of Object.entries(types)) {
                cumulative += prob;
                if (rand < cumulative) return type;
            }
            return 'normal';
        }

        function getArrowSize(damage) {
            const baseDamage = 10;
            return Math.min(3, damage / baseDamage);
        }

        function generateMap() {
            let map = Array(mapSize).fill().map(() => Array(mapSize).fill(0));
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    map[y][x] = Math.random() < 0.5 ? 1 : 0;
                }
            }
            for (let i = 0; i < 5; i++) {
                map = cellularAutomataStep(map);
            }
            for (let y = 1; y < mapSize - 1; y++) {
                for (let x = 1; x < mapSize - 1; x++) {
                    if (map[y][x] === 0 && isIsolated(x, y, map) && Math.random() < 0.1) {
                        map[y][x] = 1;
                    }
                }
            }
            map[1][1] = 0;
            map[8][8] = 0;
            return isConnected(map) ? map : generateMap();
        }

        function isIsolated(x, y, map) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (map[y + dy][x + dx] === 1) return false;
                }
            }
            return true;
        }

        function cellularAutomataStep(map) {
            const newMap = map.map(row => row.slice());
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    newMap[y][x] = countWallNeighbors(map, x, y) >= 5 ? 1 : 0;
                }
            }
            return newMap;
        }

        function countWallNeighbors(map, x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || nx >= mapSize || ny < 0 || ny >= mapSize || map[ny][nx] === 1) count++;
                }
            }
            return count;
        }

        function isConnected(map) {
            const visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
            const queue = [[1, 1]];
            visited[1][1] = true;
            while (queue.length) {
                const [x, y] = queue.shift();
                for (const dir of Object.values(directions)) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && !visited[ny][nx] && map[ny][nx] === 0) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny]);
                    }
                }
            }
            return visited[8][8];
        }

        function generateEnemies(stage) {
            const baseHealth = 300 + (stage - 1) * 10;
            const baseAttack = 5 + Math.floor((stage - 1) / 2);
            const enemyTypes = [
                { type: 'grunt', maxHealth: baseHealth, health: baseHealth, attack: baseAttack, fireChance: 0.05, moveSpeed: 0.5, symbol: 'üëæ', resistance: 'fire' },
                { type: 'sniper', maxHealth: baseHealth - 10, health: baseHealth - 10, attack: baseAttack + 2, fireChance: 0.1, moveSpeed: 0.7, symbol: 'üßü', resistance: 'ice' },
                { type: 'tank', maxHealth: baseHealth + 20, health: baseHealth + 20, attack: baseAttack + 3, fireChance: 0, moveSpeed: 1, symbol: 'üëπ', resistance: 'lightning' },
                { type: 'summoner', maxHealth: baseHealth - 20, health: baseHealth - 20, attack: baseAttack - 2, fireChance: 0, moveSpeed: 1, symbol: 'üßô‚Äç‚ôÇÔ∏è', summonCooldown: 5, resistance: 'earth' },
                { type: 'mage', maxHealth: baseHealth - 30, health: baseHealth - 30, attack: baseAttack, fireChance: 0, moveSpeed: 0.7, symbol: 'üßô‚Äç‚ôÄÔ∏è', spellCooldown: 3, spells: ['fireball', 'slow'], resistance: 'fire' }
            ];
            const enemyList = [];
            const enemyCount = Math.min(3 + Math.floor(stage / 2), 10);
            for (let i = 0; i < enemyCount; i++) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8) || enemyList.some(e => e.x === x && e.y === y));
                const enemy = {
                    x, y, health: type.health, maxHealth: type.maxHealth,
                    attack: type.attack + Math.floor(Math.random() * 3) - 1,
                    moveCooldown: 0, fireCooldown: 0, type: type.type,
                    fireChance: type.fireChance + Math.random() * 0.05,
                    moveSpeed: type.moveSpeed + Math.random() * 0.2,
                    symbol: type.symbol, speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
                    renderX: x, renderY: y, bounceTargetX: null, bounceTargetY: null, bounceTimer: 0,
                    critChance: 0.05,
                    poisonTimer: 0,
                    poisonAccumulator: 0,
                    poisonParticleTimer: 0,
                    resistance: type.resistance,
                    burnTimer: 0,
                    burnAccumulator: 0,
                    slowTimer: 0,
                    stunTimer: 0
                };
                if (type.type === 'summoner') enemy.summonCooldown = type.summonCooldown;
                if (type.type === 'mage') {
                    enemy.spellCooldown = type.spellCooldown;
                    enemy.spells = type.spells;
                }
                enemyList.push(enemy);
            }
            return enemyList;
        }

        function generateLoot() {
            const lootTypes = [
                { type: 'speed', name: 'Speed Boost', symbol: 'üèÉ', effect: (target) => target.speedBoostTimer = 10, description: 'Temporarily increases movement speed.' },
                { type: 'damage', name: 'Mega Damage', symbol: 'üí™', effect: (target) => target.megaDamageTimer = 10, description: 'Temporarily increases attack damage.' },
                { type: 'shield', name: 'Shield', symbol: 'üõ°Ô∏è', effect: (target) => target.shieldTimer = 5, description: 'Provides a temporary shield against damage.' },
                { type: 'teleport', name: 'Teleport', symbol: 'üîÆ', effect: (target) => teleportTarget(target), description: 'Teleports to a random location.' },
                { type: 'timeFreeze', name: 'Time Freeze', symbol: '‚è≥', effect: (target) => target.timeFreezeTimer = 5, description: 'Freezes time for a short duration.' },
                { type: 'invisibility', name: 'Invisibility', symbol: 'üëª', effect: (target) => target.invisibilityTimer = 10, description: 'Makes you invisible to enemies.' },
                { type: 'doubleArrow', name: 'Double Arrow', symbol: 'üèπ', effect: (target) => target.doubleArrowTimer = 10, description: 'Fires two arrows instead of one.' },
                { type: 'healthRegen', name: 'Health Regen', symbol: 'üíñ', effect: (target) => target.healthRegenTimer = 10, description: 'Regenerates health over time.' },
                { type: 'explosiveArrows', name: 'Explosive Arrows', symbol: 'üí£', effect: (target) => target.explosiveArrowsTimer = 10, description: 'Arrows explode on impact.' }
            ];
            const lootList = [];
            for (let i = 0; i < 3; i++) {
                const type = lootTypes[Math.floor(Math.random() * lootTypes.length)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8) || lootList.some(l => l.x === x && l.y === y));
                lootList.push({ x, y, ...type });
            }
            return lootList;
        }

        function teleportTarget(target) {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (currentMap[y][x] !== 0);
            target.x = x;
            target.y = y;
        }

        function createParticles(x, y, count, color, speed, life) {
            if (particles.length + count > MAX_PARTICLES) {
                particles.splice(0, particles.length + count - MAX_PARTICLES);
            }
            for (let i = 0; i < count && particles.length < MAX_PARTICLES; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = (Math.random() * speed) + 1;
                particles.push({
                    x: x * cellSize + cellSize / 2,
                    y: y * cellSize + cellSize / 2,
                    dx: Math.cos(angle) * velocity,
                    dy: Math.sin(angle) * velocity,
                    life: life,
                    maxLife: life,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function createHealParticles(x, y) {
            createParticles(x, y, 20, 'lime', 1, 1);
            particles.slice(-20).forEach(p => p.dy -= 1);
        }

        function createExplosionParticles(x, y, damage) {
            const size = getArrowSize(damage);
            createParticles(x, y, 30 * size, 'yellow', 5, 0.3);
            createParticles(x, y, 20 * size, 'orange', 3, 0.5);
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx * deltaTime * 60;
                p.y += p.dy * deltaTime * 60;
                p.life -= deltaTime;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function startCountdown() {
            countdownActive = true;
            countdownTimer = 3.5;
            countdownText = '3';
            createParticles(mapSize / 2, mapSize / 2, 50, 'red', 2, 1);
        }

        function updateCountdown(deltaTime) {
            countdownTimer -= deltaTime;
            if (countdownTimer <= 0) {
                countdownActive = false;
                countdownText = '';
            } else if (countdownTimer <= 0.5) {
                if (countdownText !== 'GO!') {
                    countdownText = 'GO!';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'blue', 3, 1);
                }
            } else if (countdownTimer <= 1.5) {
                if (countdownText !== '1') {
                    countdownText = '1';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'green', 2, 1);
                }
            } else if (countdownTimer <= 2.5) {
                if (countdownText !== '2') {
                    countdownText = '2';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'yellow', 2, 1);
                }
            }
        }

        function drawCountdown() {
            if (countdownActive) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(countdownText, logicalWidth / 2, logicalHeight / 2);
                ctx.restore();
            }
        }

        function drawChargeGauge(x, y, multiplier) {
            const maxMultiplier = 3;
            const fillRatio = (multiplier - 1) / (maxMultiplier - 1);
            let color = multiplier < 1.5 ? 'green' : multiplier <= 2.5 ? 'yellow' : 'red';
            const gaugeWidth = 30;
            const gaugeHeight = 5;
            ctx.fillStyle = 'gray';
            ctx.fillRect(x - gaugeWidth / 2, y, gaugeWidth, gaugeHeight);
            ctx.fillStyle = color;
            ctx.fillRect(x - gaugeWidth / 2, y, gaugeWidth * fillRatio, gaugeHeight);
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pulseTime += 0.02;
            document.body.style.backgroundColor = `hsl(${stage * 10}, 50%, ${50 + Math.sin(pulseTime) * 10}%)`;

            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    if (currentMap[y][x] === 0) {
                        ctx.fillStyle = currentTileSet.floorColor;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        ctx.font = "30px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = 'black';
                        ctx.fillText(currentTileSet.wall, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
                    }
                }
            }

            if (exitUnlocked) {
                ctx.fillStyle = 'white';
                ctx.fillText("üö™", 8 * cellSize + cellSize / 2, 8 * cellSize + cellSize / 2);
            }

            loot.forEach(item => {
                ctx.save();
                ctx.translate(item.x * cellSize + cellSize / 2, item.y * cellSize + cellSize / 2);
                ctx.scale(1 + Math.sin(pulseTime * 2) * 0.1, 1 + Math.sin(pulseTime * 2) * 0.1);
                ctx.fillStyle = `hsl(${pulseTime * 100 % 360}, 100%, 70%)`;
                ctx.fillText(item.symbol, 0, 0);
                ctx.restore();
            });

            enemies.forEach(enemy => {
                const renderX = enemy.bounceTimer > 0 ? 
                    enemy.x + (enemy.bounceTargetX - enemy.x) * (1 - enemy.bounceTimer / 0.2) : enemy.x;
                const renderY = enemy.bounceTimer > 0 ? 
                    enemy.y + (enemy.bounceTargetY - enemy.y) * (1 - enemy.bounceTimer / 0.2) : enemy.y;
                ctx.fillText(enemy.symbol, renderX * cellSize + cellSize / 2, renderY * cellSize + cellSize / 2);
                const healthBarWidth = 30;
                const healthBarHeight = 5;
                const healthRatio = enemy.health / enemy.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth, healthBarHeight);
                ctx.fillStyle = `hsl(120, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)`;
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);
            });

            ctx.save();
            ctx.translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
            if (player.shieldTimer > 0) {
                ctx.strokeStyle = `hsl(240, 100%, ${50 + Math.sin(pulseTime * 3) * 20}%)`;
                ctx.lineWidth = 2 + Math.sin(pulseTime * 2);
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(pulseTime) * 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillText("üßô", 0, 0);
            ctx.restore();

            const healthBarWidth = 30;
            const healthBarHeight = 5;
            const healthRatio = player.health / player.maxHealth;
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);

            const currentTime = performance.now();
            for (const dir in player.charging) {
                if (player.charging[dir]) {
                    const chargeTime = (currentTime - player.chargeStartTime[dir]) / 1000;
                    const multiplier = Math.min(3, 1 + chargeTime);
                    drawChargeGauge(player.x * cellSize + cellSize / 2, player.y * cellSize - 5, multiplier);
                    break;
                }
            }

            if (player.speedBoostTimer > 0) {
                player.trail.forEach((pos, i) => {
                    ctx.globalAlpha = 0.3 * (3 - i);
                    ctx.fillStyle = `hsl(${i * 60 + pulseTime * 100 % 360}, 100%, 50%)`;
                    ctx.fillText("üßô", pos.x * cellSize + cellSize / 2, pos.y * cellSize + cellSize / 2);
                });
                ctx.globalAlpha = 1;
            }
        }

        function drawArrows() {
            arrows.forEach(arrow => {
                const size = arrow.size || 1;
                let strokeColor;
                if (arrow.isPlayer) {
                    strokeColor = arrow.chargeColor || (player.megaDamageTimer > 0 ? `hsl(300, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)` : arrow.color);
                } else {
                    strokeColor = 'red';
                }
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = (player.megaDamageTimer > 0 && arrow.isPlayer ? 4 : 2) * size;
                ctx.beginPath();
                ctx.moveTo(arrow.x * cellSize, arrow.y * cellSize);
                ctx.lineTo((arrow.x + arrow.dx * 0.5) * cellSize, (arrow.y + arrow.dy * 0.5) * cellSize);
                ctx.stroke();

                ctx.globalAlpha = 0.5;
                ctx.fillStyle = arrow.isPlayer ? arrow.color : 'orange';
                ctx.beginPath();
                ctx.arc(arrow.x * cellSize, arrow.y * cellSize, 2 * size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                if (arrow.element === 'fire') {
                    createParticles(arrow.x, arrow.y, 1, 'red', 0.5, 0.1);
                } else if (arrow.element === 'ice') {
                    createParticles(arrow.x, arrow.y, 1, 'blue', 0.5, 0.1);
                } else if (arrow.element === 'lightning') {
                    createParticles(arrow.x, arrow.y, 1, 'yellow', 1, 0.05);
                } else if (arrow.element === 'earth') {
                    createParticles(arrow.x, arrow.y, 1, 'brown', 0.5, 0.1);
                }
            });
        }

        function drawPopups() {
            popups.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.isCritical ? 'orange' : 'yellow';
                ctx.font = p.isCritical ? '20px Arial' : '16px Arial';
                const scale = 1 + Math.sin(pulseTime * 5) * 0.2;
                ctx.save();
                ctx.translate(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2 - (1 - p.life / p.maxLife) * 20);
                ctx.scale(scale, scale);
                ctx.fillText(p.text, 0, 0);
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                if (player.speedBoostTimer > 0) {
                    player.trail.push({ x: player.x, y: player.y });
                    if (player.trail.length > 3) player.trail.shift();
                }
                player.x = newX;
                player.y = newY;
                const lootIndex = loot.findIndex(item => item.x === player.x && item.y === player.y);
                if (lootIndex >= 0) {
                    const item = loot[lootIndex];
                    if (item.type === 'potion' || typeof item.effect === 'function') {
                        const quickSlotIndex = player.quickAccess.findIndex(slot => slot === null);
                        if (quickSlotIndex !== -1) {
                            player.quickAccess[quickSlotIndex] = item;
                        } else {
                            player.inventory.push(item);
                        }
                    } else if (item.type === 'spell') {
                        const spellSlotIndex = player.spellQuickAccess.findIndex(slot => slot === null);
                        if (spellSlotIndex !== -1) {
                            player.spellQuickAccess[spellSlotIndex] = item;
                            updateCombinedSpell();
                            updateInfo();
                        } else {
                            player.inventory.push(item);
                        }
                    } else {
                        player.inventory.push(item);
                    }
                    loot.splice(lootIndex, 1);
                    createParticles(player.x, player.y, 10, 'gold', 2, 0.5);
                    updateQuickAccessDisplay();
                    updateSpellQuickAccessDisplay();
                    updateInventoryDisplay();
                }
                if (exitUnlocked && player.x === 8 && player.y === 8) advanceStage();
            }
        }

        function updateCombinedSpell() {
            const spells = player.spellQuickAccess.filter(spell => spell !== null);
            if (spells.length === 0) {
                player.combinedSpell = null;
            } else if (spells.length === 1) {
                player.combinedSpell = spells[0];
            } else {
                const allSame = spells.every(spell => spell.name === spells[0].name);
                if (allSame) {
                    const spell = spells[0];
                    player.combinedSpell = {
                        name: `Triple ${spell.name}`,
                        attack: spell.attack * 3,
                        fireRate: Math.max(0.1, spell.fireRate / 3),
                        symbol: spell.symbol,
                        spread: spell.spread,
                        isAoE: spell.isAoE,
                        poisonChance: Math.min(1, spell.poisonChance * 3),
                        element: spell.element,
                        effect: spell.effect,
                        description: `A powerful version of ${spell.name} with triple the effects.`
                    };
                } else {
                    const attack = spells.reduce((sum, spell) => sum + spell.attack, 0) / spells.length;
                    const fireRate = Math.min(...spells.map(spell => spell.fireRate));
                    const spread = spells.some(spell => spell.spread);
                    const isAoE = spells.some(spell => spell.isAoE);
                    const poisonChance = Math.max(...spells.map(spell => spell.poisonChance || 0));
                    const elements = [...new Set(spells.map(spell => spell.element).filter(el => el))];
                    const effects = [...new Set(spells.map(spell => spell.effect).filter(ef => ef))];
                    player.combinedSpell = {
                        name: 'Combined Spell',
                        attack,
                        fireRate: Math.max(0.1, fireRate),
                        symbol: 'üåå',
                        spread,
                        isAoE,
                        poisonChance,
                        element: elements[0] || null,
                        effect: effects[0] || null,
                        description: 'A combination of different spells.'
                    };
                }
            }
            updateInfo();
            updateInventoryDisplay();
        }

        function fireArrow(x, y, dx, dy, isPlayer = true, customDamage = null, chargeTime = 0) {
            if (arrows.length >= MAX_ARROWS) return;
            const shooter = isPlayer ? player : enemies.find(e => e.x === x && e.y === y);
            const critChance = shooter ? shooter.critChance : 0;
            const isCritical = Math.random() < critChance;
            const spell = isPlayer ? player.combinedSpell : null;
            const spellBonus = spell ? spell.attack : 0;
            const baseDamage = isPlayer ? player.attack : 5;
            let damage = customDamage !== null ? customDamage : (isPlayer ? (player.megaDamageTimer > 0 ? (baseDamage + spellBonus) * 2 : (baseDamage + spellBonus)) : baseDamage);
            if (isCritical) damage *= 2;
            const multiplier = isPlayer ? Math.min(3, 1 + chargeTime) : 1;
            damage *= multiplier;
            const size = getArrowSize(damage);
            const chargeColor = isPlayer ? (multiplier < 1.5 ? 'green' : multiplier <= 2.5 ? 'yellow' : 'red') : null;
            const arrow = { 
                x: x + 0.5, y: y + 0.5, dx, dy, isPlayer, damage, size, isCritical,
                isAoE: isPlayer && (spell ? spell.isAoE : false) || (player.explosiveArrowsTimer > 0),
                isPoison: isPlayer && spell && spell.poisonChance && Math.random() < spell.poisonChance,
                chargeColor: chargeColor,
                color: isPlayer ? (spell ? spellColors[spell.name] || 'blue' : 'blue') : 'red',
                element: isPlayer && spell ? spell.element : null,
                effect: isPlayer && spell ? spell.effect : null,
                effectStrength: multiplier
            };
            if (spell && spell.spread && isPlayer && arrows.length + 2 < MAX_ARROWS) {
                arrows.push({ ...arrow, dx: dx + 0.1 });
                arrows.push({ ...arrow, dx: dx - 0.1 });
            }
            arrows.push(arrow);
            if (player.doubleArrowTimer > 0 && isPlayer && arrows.length < MAX_ARROWS) {
                arrows.push({ ...arrow, x: x + 0.5 + (dx * 0.1), y: y + 0.5 + (dy * 0.1) });
            }
            if (isPlayer) {
                player.fireCooldown = Math.max(0.1, spell ? spell.fireRate : 0.5);
                const particleCount = Math.min(20, 5 + Math.floor(chargeTime * 5));
                const color = spell ? (spellColors[spell.name] || 'blue') : 'blue';
                createParticles(player.x, player.y, particleCount, color, 1, 0.1);
            }
        }

        function applyKnockback(target, dx, dy, distance = 1) {
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            if (magnitude === 0) return;
            const unitDx = dx / magnitude;
            const unitDy = dy / magnitude;
            target.bounceTargetX = Math.round(target.x + unitDx * distance);
            target.bounceTargetY = Math.round(target.y + unitDy * distance);
            if (target.bounceTargetX >= 0 && target.bounceTargetX < mapSize && target.bounceTargetY >= 0 && target.bounceTargetY < mapSize && currentMap[target.bounceTargetY][target.bounceTargetX] === 0) {
                target.bounceTimer = 0.2;
            } else {
                target.bounceTargetX = target.x;
                target.bounceTargetY = target.y;
            }
        }

        function dropLoot(x, y) {
            let drops = [];
            const roll = Math.random();
            const isLastEnemy = enemies.length === 1;
            if (roll < 0.5 || (isLastEnemy && !hasDroppedThisStage)) {
                let typeRoll = Math.random();
                let type = typeRoll < 0.7 ? rareSpells : typeRoll < 0.9 ? rareArmor : rarePotions;
                drops.push({ x, y, ...type[Math.floor(Math.random() * type.length)] });
                hasDroppedThisStage = true;
            }
            if (Math.random() < 0.2) {
                let typeRoll = Math.random();
                let type = typeRoll < 0.7 ? rareSpells : typeRoll < 0.9 ? rareArmor : rarePotions;
                drops.push({ x, y, ...type[Math.floor(Math.random() * type.length)] });
            }
            drops.forEach(drop => loot.push(drop));
        }

        function applyAoEDamage(centerX, centerY, damage) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < mapSize && y >= 0 && y < mapSize) {
                        for (let i = 0; i < enemies.length; i++) {
                            const enemy = enemies[i];
                            if (enemy.x === x && enemy.y === y && enemy.shieldTimer <= 0) {
                                let finalDamage = damage;
                                if (enemy.resistance === 'earth') finalDamage *= 0.5;
                                enemy.health -= finalDamage;
                                addDamagePopup(enemy.x, enemy.y, finalDamage);
                                let knockDx = x - centerX;
                                let knockDy = y - centerY;
                                if (knockDx !== 0 || knockDy !== 0) applyKnockback(enemy, knockDx, knockDy, 1);
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(i, 1);
                                    i--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        function checkLevelUp() {
            if (player.xp >= player.xpToNext) {
                player.level += 1;
                player.xp -= player.xpToNext;
                player.xpToNext = Math.floor(player.xpToNext * 1.5);
                player.maxHealth += 20;
                player.health = player.maxHealth;
                player.attack += 5;
                showNotification(`Level Up! Level ${player.level}. Max Health: ${player.maxHealth}, Attack: ${player.attack}`);
                createParticles(player.x, player.y, 30, 'gold', 2, 1);
                updateInfo();
            }
        }

        function updateGameState(deltaTime) {
            if (countdownActive) {
                updateCountdown(deltaTime);
                return;
            }

            player.moveCooldown -= deltaTime;
            player.fireCooldown -= deltaTime;
            player.speedBoostTimer -= deltaTime;
            player.megaDamageTimer -= deltaTime;
            player.shieldTimer -= deltaTime;
            player.teleportTimer -= deltaTime;
            player.timeFreezeTimer -= deltaTime;
            player.invisibilityTimer -= deltaTime;
            player.doubleArrowTimer -= deltaTime;
            player.healthRegenTimer -= deltaTime;
            player.explosiveArrowsTimer -= deltaTime;
            player.slowTimer -= deltaTime;
            if (player.moveCooldown < 0) player.moveCooldown = 0;
            if (player.fireCooldown < 0) player.fireCooldown = 0;
            if (player.speedBoostTimer < 0) player.speedBoostTimer = 0;
            if (player.megaDamageTimer < 0) player.megaDamageTimer = 0;
            if (player.shieldTimer < 0) player.shieldTimer = 0;
            if (player.teleportTimer < 0) player.teleportTimer = 0;
            if (player.timeFreezeTimer < 0) player.timeFreezeTimer = 0;
            if (player.invisibilityTimer < 0) player.invisibilityTimer = 0;
            if (player.doubleArrowTimer < 0) player.doubleArrowTimer = 0;
            if (player.healthRegenTimer < 0) player.healthRegenTimer = 0;
            if (player.explosiveArrowsTimer < 0) player.explosiveArrowsTimer = 0;
            if (player.slowTimer < 0) player.slowTimer = 0;

            if (player.healthRegenTimer > 0 && player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + deltaTime * 10);
                createHealParticles(player.x, player.y);
                updateInfo();
            }

            const moveCooldown = player.speedBoostTimer > 0 ? 0.05 : (player.slowTimer > 0 ? 0.2 : 0.1);
            if (player.moveCooldown <= 0 && (movingUp || movingLeft || movingRight || movingDown)) {
                if (movingUp) movePlayer(0, -1);
                else if (movingDown) movePlayer(0, 1);
                else if (movingLeft) movePlayer(-1, 0);
                else if (movingRight) movePlayer(1, 0);
                player.moveCooldown = moveCooldown;
            }

            if (player.timeFreezeTimer <= 0) {
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    enemy.moveCooldown -= deltaTime;
                    enemy.fireCooldown -= deltaTime;
                    if (enemy.moveCooldown < 0) enemy.moveCooldown = 0;
                    if (enemy.fireCooldown < 0) enemy.fireCooldown = 0;

                    if (enemy.bounceTimer > 0) {
                        enemy.bounceTimer -= deltaTime;
                        if (enemy.bounceTimer <= 0) {
                            enemy.x = enemy.bounceTargetX;
                            enemy.y = enemy.bounceTargetY;
                            enemy.bounceTimer = 0;
                        }
                    }

                    if (enemy.burnTimer > 0) {
                        enemy.burnTimer -= deltaTime;
                        if (enemy.burnTimer < 0) enemy.burnTimer = 0;
                        enemy.burnAccumulator += deltaTime;
                        while (enemy.burnAccumulator >= BURN_INTERVAL) {
                            enemy.health -= BURN_DAMAGE;
                            enemy.burnAccumulator -= BURN_INTERVAL;
                            addDamagePopup(enemy.x, enemy.y, BURN_DAMAGE);
                            if (enemy.health <= 0) {
                                player.xp += 50;
                                checkLevelUp();
                                updateInfo();
                                createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                dropLoot(enemy.x, enemy.y);
                                enemies.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                        createParticles(enemy.x, enemy.y, 1, 'orange', 0.5, 0.1);
                    }

                    if (enemy.slowTimer > 0) {
                        enemy.slowTimer -= deltaTime;
                        if (enemy.slowTimer < 0) enemy.slowTimer = 0;
                        enemy.moveCooldown += deltaTime * (1 / SLOW_FACTOR - 1);
                        createParticles(enemy.x, enemy.y, 1, 'blue', 0.5, 0.1);
                    }

                    if (enemy.stunTimer > 0) {
                        enemy.stunTimer -= deltaTime;
                        if (enemy.stunTimer < 0) enemy.stunTimer = 0;
                        enemy.moveCooldown = Math.max(enemy.moveCooldown, 0.1);
                        enemy.fireCooldown = Math.max(enemy.fireCooldown, 0.1);
                        createParticles(enemy.x, enemy.y, 1, 'yellow', 1, 0.05);
                    }

                    if (enemy.type === 'summoner' && enemy.stunTimer <= 0) {
                        enemy.summonCooldown -= deltaTime;
                        if (enemy.summonCooldown <= 0) {
                            const possibleSpots = [];
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = enemy.x + dx;
                                    const ny = enemy.y + dy;
                                    if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && currentMap[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                        possibleSpots.push({x: nx, y: ny});
                                    }
                                }
                            }
                            if (possibleSpots.length > 0) {
                                const spot = possibleSpots[Math.floor(Math.random() * possibleSpots.length)];
                                const newEnemy = {
                                    x: spot.x, y: spot.y, health: 50, maxHealth: 50, attack: 5,
                                    moveCooldown: 0, fireCooldown: 0, type: 'grunt',
                                    fireChance: 0.05 + Math.random() * 0.05,
                                    moveSpeed: 0.5 + Math.random() * 0.2,
                                    symbol: 'üëæ', speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
                                    renderX: spot.x, renderY: spot.y, bounceTargetX: null, bounceTargetY: null, bounceTimer: 0,
                                    critChance: 0.05,
                                    poisonTimer: 0,
                                    poisonAccumulator: 0,
                                    poisonParticleTimer: 0,
                                    resistance: 'fire',
                                    burnTimer: 0,
                                    burnAccumulator: 0,
                                    slowTimer: 0,
                                    stunTimer: 0
                                };
                                enemies.push(newEnemy);
                                enemy.summonCooldown = 5;
                                createParticles(spot.x, spot.y, 15, 'purple', 2, 0.5);
                            }
                        }
                    }

                    if (enemy.type === 'mage' && enemy.stunTimer <= 0) {
                        enemy.spellCooldown -= deltaTime;
                        if (enemy.spellCooldown <= 0 && isInLineOfSight(enemy) && player.invisibilityTimer <= 0) {
                            const spell = enemy.spells[Math.floor(Math.random() * enemy.spells.length)];
                            if (spell === 'fireball') {
                                applyAoEDamage(player.x, player.y, 10);
                                addExplosion(player.x, player.y, false);
                                createExplosionParticles(player.x, player.y, 10);
                            } else if (spell === 'slow') {
                                player.slowTimer = 5;
                                createParticles(player.x, player.y, 15, 'gray', 1, 1);
                            }
                            enemy.spellCooldown = 3;
                        }
                    }

                    if (enemy.fireCooldown <= 0 && enemy.fireChance > 0 && Math.random() < enemy.fireChance && isInLineOfSight(enemy) && player.invisibilityTimer <= 0 && enemy.stunTimer <= 0) {
                        const direction = getDirectionToPlayer(enemy);
                        if (direction) {
                            const attackType = chooseAttackType(enemy);
                            const multiplier = attackMultipliers[attackType];
                            const damage = enemy.attack * multiplier;
                            fireArrow(enemy.x, enemy.y, direction.dx, direction.dy, false, damage);
                            enemy.fireCooldown = 1;
                        }
                    }
                    if (enemy.moveCooldown <= 0 && enemy.stunTimer <= 0) {
                        const target = getClosestTarget(enemy);
                        const dir = getDirectionToTarget(enemy, target);
                        const newX = enemy.x + dir.dx;
                        const newY = enemy.y + dir.dy;
                        if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                        enemy.moveCooldown = enemy.moveSpeed;
                    }

                    if (enemy.poisonTimer > 0) {
                        enemy.poisonTimer -= deltaTime;
                        if (enemy.poisonTimer < 0) enemy.poisonTimer = 0;
                        enemy.poisonParticleTimer -= deltaTime;
                        if (enemy.poisonParticleTimer <= 0) {
                            createParticles(enemy.x, enemy.y, 3, 'green', 0.5, 0.2);
                            enemy.poisonParticleTimer = 0.1;
                        }
                        enemy.poisonAccumulator += deltaTime;
                        while (enemy.poisonAccumulator >= POISON_INTERVAL) {
                            enemy.health -= POISON_DAMAGE;
                            enemy.poisonAccumulator -= POISON_INTERVAL;
                            addDamagePopup(enemy.x, enemy.y, POISON_DAMAGE);
                            if (enemy.health <= 0) {
                                player.xp += 50;
                                checkLevelUp();
                                updateInfo();
                                createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                dropLoot(enemy.x, enemy.y);
                                enemies.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                    }
                }
            }

            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                arrow.x += arrow.dx * 5 * deltaTime;
                arrow.y += arrow.dy * 5 * deltaTime;
                const cellX = Math.floor(arrow.x);
                const cellY = Math.floor(arrow.y);

                if (cellX < 0 || cellX >= mapSize || cellY < 0 || cellY >= mapSize || currentMap[cellY][cellX] === 1) {
                    if (arrow.isAoE) {
                        applyAoEDamage(cellX, cellY, arrow.damage);
                        createExplosionParticles(cellX, cellY, arrow.damage);
                    } else {
                        if (arrow.element === 'fire') createParticles(cellX, cellY, 20, 'red', 2, 0.5);
                        else if (arrow.element === 'ice') createParticles(cellX, cellY, 20, 'blue', 2, 0.5);
                        else if (arrow.element === 'lightning') createParticles(cellX, cellY, 20, 'yellow', 3, 0.3);
                        else if (arrow.element === 'earth') createParticles(cellX, cellY, 20, 'brown', 2, 0.5);
                        else createParticles(cellX, cellY, 10 * arrow.size, arrow.color, 2, 0.3);
                    }
                    arrows.splice(i, 1);
                } else if (arrow.isPlayer) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (enemy.x === cellX && enemy.y === cellY) {
                            if (arrow.isAoE) {
                                applyAoEDamage(cellX, cellY, arrow.damage);
                                createExplosionParticles(cellX, cellY, arrow.damage);
                            } else if (enemy.shieldTimer <= 0) {
                                let finalDamage = arrow.damage;
                                if (arrow.element && enemy.resistance === arrow.element) {
                                    finalDamage *= 0.5;
                                }
                                enemy.health -= finalDamage;
                                const dx = enemy.x - player.x;
                                const dy = enemy.y - player.y;
                                applyKnockback(enemy, dx, dy, 2);
                                if (arrow.isCritical) {
                                    addCriticalDamagePopup(enemy.x, enemy.y, finalDamage);
                                } else {
                                    addDamagePopup(enemy.x, enemy.y, finalDamage);
                                }
                                if (arrow.element === 'fire') createParticles(enemy.x, enemy.y, 20, 'red', 2, 0.5);
                                else if (arrow.element === 'ice') createParticles(enemy.x, enemy.y, 20, 'blue', 2, 0.5);
                                else if (arrow.element === 'lightning') createParticles(enemy.x, enemy.y, 20, 'yellow', 3, 0.3);
                                else if (arrow.element === 'earth') createParticles(enemy.x, enemy.y, 20, 'brown', 2, 0.5);
                                else createParticles(enemy.x, enemy.y, 15 * arrow.size, arrow.color, 2, 0.4);
                                if (arrow.isPoison) {
                                    enemy.poisonTimer = POISON_DURATION;
                                    enemy.poisonAccumulator = 0;
                                    enemy.poisonParticleTimer = 0;
                                }
                                if (arrow.effect === 'burn') {
                                    enemy.burnTimer = 5 * arrow.effectStrength;
                                    enemy.burnAccumulator = 0;
                                } else if (arrow.effect === 'slow') {
                                    enemy.slowTimer = 3 * arrow.effectStrength;
                                } else if (arrow.effect === 'stun' && Math.random() < 0.2) {
                                    enemy.stunTimer = 2 * arrow.effectStrength;
                                }
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(j, 1);
                                    j--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                            arrows.splice(i, 1);
                            break;
                        }
                    }
                } else if (cellX === player.x && cellY === player.y) {
                    if (player.shieldTimer > 0) {
                        arrow.dx = -arrow.dx;
                        arrow.dy = -arrow.dy;
                        arrow.isPlayer = false;
                        createParticles(player.x, player.y, 10 * arrow.size, 'blue', 2, 0.3);
                        if (arrows.length + 4 < MAX_ARROWS) {
                            fireArrow(player.x, player.y, 0, -1, true);
                            fireArrow(player.x, player.y, 0, 1, true);
                            fireArrow(player.x, player.y, -1, 0, true);
                            fireArrow(player.x, player.y, 1, 0, true);
                        }
                    } else {
                        const damage = arrow.damage - (player.equippedArmor ? player.equippedArmor.defense : 0);
                        player.health -= Math.max(damage, 0);
                        applyKnockback(player, -arrow.dx, -arrow.dy, 1);
                        if (arrow.isCritical) {
                            addCriticalDamagePopup(player.x, player.y, Math.max(damage, 0));
                        } else {
                            addDamagePopup(player.x, player.y, Math.max(damage, 0));
                        }
                        createParticles(player.x, player.y, 10 * arrow.size, arrow.color, 2, 0.3);
                        if (player.health <= 0) gameOver();
                        arrows.splice(i, 1);
                    }
                    updateInfo();
                }
            }

            updateParticles(deltaTime);
            for (let i = popups.length - 1; i >= 0; i--) {
                popups[i].life -= deltaTime;
                if (popups[i].life <= 0) popups.splice(i, 1);
            }
        }

        function renderScene() {
            drawMap();
            drawArrows();
            drawParticles();
            drawPopups();
            drawCountdown();
        }

        function gameLoop(timestamp) {
            const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1);
            lastTimestamp = timestamp;
            updateGameState(deltaTime);
            renderScene();
            requestAnimationFrame(gameLoop);
        }

        function addDamagePopup(x, y, damage) {
            const roundedDamage = damage.toFixed(2);
            popups.push({ text: `-${roundedDamage}`, x, y, life: 1, maxLife: 1, isCritical: false });
        }

        function addCriticalDamagePopup(x, y, damage) {
            const roundedDamage = damage.toFixed(2);
            popups.push({ text: `CRIT! -${roundedDamage}`, x, y, life: 1.5, maxLife: 1.5, isCritical: true });
            createParticles(x, y, 20, 'gold', 3, 0.5);
        }

        function addExplosion(x, y, isPlayer) {
            popups.push({ text: 'üí•', x, y, life: 0.5, maxLife: 0.5, isDamage: false });
        }

        function gameOver() {
            player.health = Math.floor(player.maxHealth / 2);
            player.x = 1;
            player.y = 1;
            showNotification("You died! Respawned with half health.");
            createParticles(player.x, player.y, 20, 'purple', 2, 0.5);
            updateInfo();
        }

        function advanceStage() {
            stage++;
            player.x = 1;
            player.y = 1;
            currentMap = generateMap();
            enemies = generateEnemies(stage);
            loot = generateLoot();
            exitUnlocked = false;
            hasDroppedThisStage = false;
            currentTileSet = tileSets[(stage - 1) % tileSets.length];
            createParticles(player.x, player.y, 30, 'green', 3, 0.7);
            updateInfo();
            showNotification(`Welcome to Stage ${stage}!`);
            startCountdown();
        }

        function updateInfo() {
            document.getElementById('stage').textContent = `Stage: ${stage}`;
            document.getElementById('health').textContent = `Health: ${Math.floor(player.health)}/${player.maxHealth}`;
            document.getElementById('level').textContent = `Level: ${player.level}`;
            document.getElementById('xp').textContent = `XP: ${player.xp}/${player.xpToNext}`;
            document.getElementById('equippedSpell').textContent = `Spell: ${player.combinedSpell ? player.combinedSpell.name : 'None'}`;
        }

        function isInLineOfSight(enemy) {
            const dx = Math.abs(enemy.x - player.x);
            const dy = Math.abs(enemy.y - player.y);
            if (dx === 0) {
                const y1 = Math.min(enemy.y, player.y);
                const y2 = Math.max(enemy.y, player.y);
                for (let y = y1 + 1; y < y2; y++) if (currentMap[y][enemy.x] === 1) return false;
                return true;
            } else if (dy === 0) {
                const x1 = Math.min(enemy.x, player.x);
                const x2 = Math.max(enemy.x, player.x);
                for (let x = x1 + 1; x < x2; x++) if (currentMap[enemy.y][x] === 1) return false;
                return true;
            }
            return false;
        }

        function getDirectionToPlayer(enemy) {
            if (enemy.x === player.x) return enemy.y < player.y ? directions.down : directions.up;
            if (enemy.y === player.y) return enemy.x < player.x ? directions.right : directions.left;
            return null;
        }

        function getClosestTarget(enemy) {
            return player;
        }

        function getDirectionToTarget(enemy, target) {
            const dx = target.x - enemy.x;
            const dy = target.y - enemy.y;
            if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? directions.right : directions.left;
            return dy > 0 ? directions.down : directions.up;
        }

        function updateInventoryDisplay() {
            document.getElementById('inventoryEquippedSpell').textContent = `Spell: ${player.combinedSpell ? player.combinedSpell.name : 'None'}`;
            document.getElementById('equippedArmor').textContent = `Armor: ${player.equippedArmor ? player.equippedArmor.name : 'None'}`;
            const list = document.getElementById('inventoryList');
            list.innerHTML = '';

            const groups = {
                spell: { label: 'Spells', items: [] },
                armor: { label: 'Armor', items: [] },
                potion: { label: 'Potions', items: [] },
                other: { label: 'Other Items', items: [] }
            };

            player.inventory.forEach((item, index) => {
                const group = item.type === 'spell' ? 'spell' : 
                              item.type === 'armor' ? 'armor' : 
                              item.type === 'potion' ? 'potion' : 'other';
                groups[group].items.push({ item, index });
            });

            for (const [key, group] of Object.entries(groups)) {
                if (group.items.length > 0) {
                    const header = document.createElement('h4');
                    header.textContent = group.label;
                    list.appendChild(header);
                    group.items.forEach(({ item, index }) => {
                        const li = document.createElement('li');
                        let icon = item.type === 'spell' ? '‚ú®' : item.type === 'armor' ? 'üõ°Ô∏è' : item.type === 'potion' ? 'üß™' : 'üéÅ';
                        li.textContent = `${icon} ${item.name || item.type}`;
                        li.title = item.description || 'No description available.';
                        li.draggable = true;
                        li.setAttribute('data-index', index);
                        li.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', index));
                        const actionButton = document.createElement('button');
                        actionButton.textContent = item.type === 'spell' || item.type === 'armor' ? 'Equip' : 
                                                  item.type === 'potion' ? 'Consume' : 'Use';
                        actionButton.addEventListener('click', () => useItem(index));
                        li.appendChild(actionButton);
                        list.appendChild(li);
                    });
                }
            }
        }

        function useItem(index) {
            const item = player.inventory[index];
            if (item.type === 'spell') {
                if (!hasEquippedSpell) {
                    showNotification("You've equipped a spell. Use the firing controls to cast it in combat‚Äîit won't be consumed.");
                    hasEquippedSpell = true;
                }
                const spellSlotIndex = player.spellQuickAccess.findIndex(slot => slot === null);
                if (spellSlotIndex !== -1) {
                    player.spellQuickAccess[spellSlotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateCombinedSpell();
                } else {
                    showNotification("Spell quick-bar is full. Remove a spell to equip this one.");
                }
            } else if (item.type === 'armor') {
                if (player.equippedArmor) player.inventory.push(player.equippedArmor);
                player.equippedArmor = item;
                player.inventory.splice(index, 1);
            } else if (item.type === 'potion') {
                player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                player.inventory.splice(index, 1);
                createHealParticles(player.x, player.y);
                updateInfo();
            } else if (item.effect) {
                item.effect(player);
                player.inventory.splice(index, 1);
            }
            updateInventoryDisplay();
            updateSpellQuickAccessDisplay();
        }

        const quickSlots = document.querySelectorAll('.quickSlot');
        quickSlots.forEach(slot => {
            slot.addEventListener('click', () => useQuickAccessItem(parseInt(slot.getAttribute('data-slot'), 10)));
            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && (item.type === 'potion' || typeof item.effect === 'function')) {
                    slot.classList.remove('drag-reject');
                } else {
                    slot.classList.add('drag-reject');
                }
            });
            slot.addEventListener('dragleave', () => slot.classList.remove('drag-reject'));
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                slot.classList.remove('drag-reject');
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && (item.type === 'potion' || typeof item.effect === 'function')) {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                    player.quickAccess[slotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateInventoryDisplay();
                    updateQuickAccessDisplay();
                }
            });
        });

        function updateQuickAccessDisplay() {
            quickSlots.forEach(slot => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.quickAccess[slotIndex];
                slot.querySelector('.item').textContent = item ? item.symbol : '';
                slot.title = item ? item.description : '';
            });
        }

        function useQuickAccessItem(slotIndex) {
            const item = player.quickAccess[slotIndex];
            if (item) {
                if (item.type === 'potion') {
                    player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                    player.quickAccess[slotIndex] = null;
                    createHealParticles(player.x, player.y);
                    updateInfo();
                } else if (item.effect) {
                    item.effect(player);
                    player.quickAccess[slotIndex] = null;
                }
                updateQuickAccessDisplay();
            }
        }

        const spellSlots = document.querySelectorAll('.spellSlot');
        spellSlots.forEach(slot => {
            slot.addEventListener('click', () => equipSpellFromQuickAccess(parseInt(slot.getAttribute('data-slot'), 10)));
            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && item.type === 'spell') {
                    slot.classList.remove('drag-reject');
                } else {
                    slot.classList.add('drag-reject');
                }
            });
            slot.addEventListener('dragleave', () => slot.classList.remove('drag-reject'));
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                slot.classList.remove('drag-reject');
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && item.type === 'spell') {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                    if (player.spellQuickAccess[slotIndex]) {
                        player.inventory.push(player.spellQuickAccess[slotIndex]);
                    }
                    player.spellQuickAccess[slotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateInventoryDisplay();
                    updateSpellQuickAccessDisplay();
                    updateCombinedSpell();
                }
            });
        });

        function updateSpellQuickAccessDisplay() {
            spellSlots.forEach(slot => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.spellQuickAccess[slotIndex];
                slot.querySelector('.item').textContent = item ? item.symbol : '';
                slot.title = item ? item.description : '';
                if (item && player.combinedSpell && player.combinedSpell.name === `Triple ${item.name}`) {
                    slot.style.borderColor = 'gold';
                } else {
                    slot.style.borderColor = '#ccc';
                }
            });
        }

        function equipSpellFromQuickAccess(slotIndex) {
            const spell = player.spellQuickAccess[slotIndex];
            if (spell) {
                player.inventory.push(spell);
                player.spellQuickAccess[slotIndex] = null;
                updateInventoryDisplay();
                updateSpellQuickAccessDisplay();
                updateCombinedSpell();
            }
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
        }

        document.getElementById('moveUp').addEventListener('pointerdown', () => movingUp = true);
        document.getElementById('moveUp').addEventListener('pointerup', () => movingUp = false);
        document.getElementById('moveLeft').addEventListener('pointerdown', () => movingLeft = true);
        document.getElementById('moveLeft').addEventListener('pointerup', () => movingLeft = false);
        document.getElementById('moveRight').addEventListener('pointerdown', () => movingRight = true);
        document.getElementById('moveRight').addEventListener('pointerup', () => movingRight = false);
        document.getElementById('moveDown').addEventListener('pointerdown', () => movingDown = true);
        document.getElementById('moveDown').addEventListener('pointerup', () => movingDown = false);

        document.addEventListener('pointerup', () => {
            movingUp = movingLeft = movingRight = movingDown = false;
        });

        document.getElementById('fireUp').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0 && !player.charging.up) {
                player.charging.up = true;
                player.chargeStartTime.up = performance.now();
            }
        });
        document.getElementById('fireUp').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.up) {
                const chargeTime = (performance.now() - player.chargeStartTime.up) / 1000;
                fireArrow(player.x, player.y, 0, -1, true, null, chargeTime);
                player.charging.up = false;
            }
        });
        document.getElementById('fireLeft').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0 && !player.charging.left) {
                player.charging.left = true;
                player.chargeStartTime.left = performance.now();
            }
        });
        document.getElementById('fireLeft').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.left) {
                const chargeTime = (performance.now() - player.chargeStartTime.left) / 1000;
                fireArrow(player.x, player.y, -1, 0, true, null, chargeTime);
                player.charging.left = false;
            }
        });
        document.getElementById('fireRight').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0 && !player.charging.right) {
                player.charging.right = true;
                player.chargeStartTime.right = performance.now();
            }
        });
        document.getElementById('fireRight').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.right) {
                const chargeTime = (performance.now() - player.chargeStartTime.right) / 1000;
                fireArrow(player.x, player.y, 1, 0, true, null, chargeTime);
                player.charging.right = false;
            }
        });
        document.getElementById('fireDown').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0 && !player.charging.down) {
                player.charging.down = true;
                player.chargeStartTime.down = performance.now();
            }
        });
        document.getElementById('fireDown').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.down) {
                const chargeTime = (performance.now() - player.chargeStartTime.down) / 1000;
                fireArrow(player.x, player.y, 0, 1, true, null, chargeTime);
                player.charging.down = false;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'w') movingUp = true;
            if (e.key === 'a') movingLeft = true;
            if (e.key === 's') movingDown = true;
            if (e.key === 'd') movingRight = true;
            if (e.key === 'ArrowUp' && player.fireCooldown <= 0 && !player.charging.up) {
                player.charging.up = true;
                player.chargeStartTime.up = performance.now();
            }
            if (e.key === 'ArrowLeft' && player.fireCooldown <= 0 && !player.charging.left) {
                player.charging.left = true;
                player.chargeStartTime.left = performance.now();
            }
            if (e.key === 'ArrowRight' && player.fireCooldown <= 0 && !player.charging.right) {
                player.charging.right = true;
                player.chargeStartTime.right = performance.now();
            }
            if (e.key === 'ArrowDown' && player.fireCooldown <= 0 && !player.charging.down) {
                player.charging.down = true;
                player.chargeStartTime.down = performance.now();
            }
            if (e.key >= '1' && e.key <= '5') useQuickAccessItem(parseInt(e.key) - 1);
            if (e.key >= '6' && e.key <= '8') equipSpellFromQuickAccess(parseInt(e.key) - 6);
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'w') movingUp = false;
            if (e.key === 'a') movingLeft = false;
            if (e.key === 's') movingDown = false;
            if (e.key === 'd') movingRight = false;
            if (e.key === 'ArrowUp' && player.charging.up) {
                const chargeTime = (performance.now() - player.chargeStartTime.up) / 1000;
                fireArrow(player.x, player.y, 0, -1, true, null, chargeTime);
                player.charging.up = false;
            }
            if (e.key === 'ArrowLeft' && player.charging.left) {
                const chargeTime = (performance.now() - player.chargeStartTime.left) / 1000;
                fireArrow(player.x, player.y, -1, 0, true, null, chargeTime);
                player.charging.left = false;
            }
            if (e.key === 'ArrowRight' && player.charging.right) {
                const chargeTime = (performance.now() - player.chargeStartTime.right) / 1000;
                fireArrow(player.x, player.y, 1, 0, true, null, chargeTime);
                player.charging.right = false;
            }
            if (e.key === 'ArrowDown' && player.charging.down) {
                const chargeTime = (performance.now() - player.chargeStartTime.down) / 1000;
                fireArrow(player.x, player.y, 0, 1, true, null, chargeTime);
                player.charging.down = false;
            }
        });

        document.getElementById('toggleInventory').addEventListener('click', () => {
            const inventoryDiv = document.getElementById('inventory');
            inventoryDiv.style.display = inventoryDiv.style.display === 'none' ? 'block' : 'none';
            if (inventoryDiv.style.display === 'block') updateInventoryDisplay();
        });

        updateCombinedSpell();
        startCountdown();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
