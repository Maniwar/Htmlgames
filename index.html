<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler - Mage Quest</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            transition: background-color 1s;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        #gameCanvas {
            border: 1px solid #000;
            display: block;
        }
        #controls, #quickAccessBar, #weaponQuickBar {
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        .dpad {
            width: 30vw;
            height: 30vw;
            max-width: 120px;
            max-height: 120px;
            position: relative;
        }
        .dpad button {
            position: absolute;
            width: 8vw;
            height: 8vw;
            max-width: 32px;
            max-height: 32px;
            background: #ccc;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .up { top: 0; left: 50%; transform: translateX(-50%); }
        .left { top: 50%; left: 0; transform: translateY(-50%); }
        .right { top: 50%; right: 0; transform: translateY(-50%); }
        .down { bottom: 0; left: 50%; transform: translateX(-50%); }
        #info {
            text-align: center;
            margin-bottom: 10px;
            font-family: Arial, sans-serif;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        #inventory {
            border: 1px solid gray;
            padding: 10px;
            display: none;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.8);
        }
        #inventoryList {
            list-style-type: none;
            padding: 0;
        }
        #inventoryList li {
            margin: 5px 0;
            cursor: move;
        }
        #inventoryList li button {
            margin-left: 10px;
        }
        #quickAccessBar, #weaponQuickBar {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        .quickSlot, .weaponSlot {
            position: relative;
            width: 50px;
            height: 50px;
            border: 2px solid #ccc;
            margin: 0 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eee;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .quickSlot:hover, .weaponSlot:hover {
            background-color: #ddd;
            transform: scale(1.1);
        }
        .key {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 12px;
            color: #333;
        }
        .item {
            font-size: 24px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #notification {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">
            <span id="stage">Stage: 1</span> | 
            <span id="health">Health: 100/100</span> | 
            <span id="level">Level: 1</span> | 
            <span id="xp">XP: 0/100</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="controls">
            <div id="movementDpad" class="dpad">
                <button class="up" id="moveUp">‚¨ÜÔ∏è</button>
                <button class="left" id="moveLeft">‚¨ÖÔ∏è</button>
                <button class="right" id="moveRight">‚û°Ô∏è</button>
                <button class="down" id="moveDown">‚¨áÔ∏è</button>
            </div>
            <div id="firingDpad" class="dpad">
                <button class="up" id="fireUp">üî•‚¨ÜÔ∏è</button>
                <button class="left" id="fireLeft">üî•‚¨ÖÔ∏è</button>
                <button class="right" id="fireRight">üî•‚û°Ô∏è</button>
                <button class="down" id="fireDown">üî•‚¨áÔ∏è</button>
            </div>
        </div>
        <button id="toggleInventory">Inventory</button>
        <div id="inventory">
            <h3>Equipped:</h3>
            <p id="equippedWeapon">Weapon: None</p>
            <p id="equippedArmor">Armor: None</p>
            <h3>Inventory:</h3>
            <ul id="inventoryList"></ul>
        </div>
        <div id="quickAccessBar">
            <div class="quickSlot" data-slot="0"><span class="key">1</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="1"><span class="key">2</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="2"><span class="key">3</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="3"><span class="key">4</span><span class="item"></span></div>
            <div class="quickSlot" data-slot="4"><span class="key">5</span><span class="item"></span></div>
        </div>
        <div id="weaponQuickBar">
            <div class="weaponSlot" data-slot="0"><span class="key">6</span><span class="item"></span></div>
            <div class="weaponSlot" data-slot="1"><span class="key">7</span><span class="item"></span></div>
            <div class="weaponSlot" data-slot="2"><span class="key">8</span><span class="item"></span></div>
        </div>
        <div id="notification"></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 40;
        const mapSize = 10;
        const logicalWidth = 400;
        const logicalHeight = 400;
        const directions = {
            up: { dx: 0, dy: -1 },
            left: { dx: -1, dy: 0 },
            right: { dx: 1, dy: 0 },
            down: { dx: 0, dy: 1 }
        };
        const MAX_ARROWS = 50;  // Cap on number of arrows
        const MAX_PARTICLES = 500;  // Cap on number of particles

        function resizeCanvas() {
            const displaySize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.width = displaySize * pixelRatio;
            canvas.height = displaySize * pixelRatio;
            canvas.style.width = displaySize + 'px';
            canvas.style.height = displaySize + 'px';
            const scale = canvas.width / logicalWidth;
            ctx.setTransform(scale, 0, 0, scale, 0, 0);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let stage = 1;
        let player = {
            x: 1, y: 1, health: 100, maxHealth: 100, attack: 10, level: 1, xp: 0, xpToNext: 100,
            moveCooldown: 0, fireCooldown: 0, speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
            teleportTimer: 0, timeFreezeTimer: 0, invisibilityTimer: 0, doubleArrowTimer: 0,
            healthRegenTimer: 0, explosiveArrowsTimer: 0, slowTimer: 0, trail: [],
            equippedWeapon: null, equippedArmor: null, inventory: [],
            quickAccess: [null, null, null, null, null],
            weaponQuickAccess: [null, null, null],
            charging: { up: false, left: false, right: false, down: false },
            chargeStartTime: { up: 0, left: 0, right: 0, down: 0 }
        };
        let currentMap = generateMap();
        let enemies = generateEnemies(stage);
        let loot = generateLoot();
        let arrows = [];
        let popups = [];
        let particles = [];
        let movingUp = false, movingLeft = false, movingRight = false, movingDown = false;
        let exitUnlocked = false;
        let lastTimestamp = 0;
        let hasDroppedThisStage = false;
        let pulseTime = 0;

        let countdownActive = false;
        let countdownTimer = 0;
        let countdownText = '';

        const tileSets = [
            { wall: 'üß±', floorColor: '#808080' },
            { wall: 'üå≥', floorColor: '#228B22' },
            { wall: 'üè∞', floorColor: '#A9A9A9' },
            { wall: 'ü™®', floorColor: '#EDC9AF' }
        ];
        let currentTileSet = tileSets[0];

        const rareWeapons = [
            { type: 'weapon', name: 'Bow', attack: 15, fireRate: 0.5, symbol: 'üèπ', spread: false, isAoE: false },
            { type: 'weapon', name: 'Crossbow', attack: 20, fireRate: 0.3, symbol: 'üèπ', spread: false, isAoE: false },
            { type: 'weapon', name: 'Shotgun', attack: 10, fireRate: 0.7, symbol: 'üî´', spread: true, isAoE: false },
            { type: 'weapon', name: 'Grenade Launcher', attack: 25, fireRate: 1.0, symbol: 'üí£', spread: false, isAoE: true },
            { type: 'weapon', name: 'Sniper Rifle', attack: 40, fireRate: 1.5, symbol: 'üî´', spread: false, isAoE: false },
            { type: 'weapon', name: 'Machine Gun', attack: 5, fireRate: 0.1, symbol: 'üî´', spread: false, isAoE: false }
        ];
        const rareArmor = [
            { type: 'armor', name: 'Leather Armor', defense: 5, symbol: 'üõ°Ô∏è' },
            { type: 'armor', name: 'Chainmail', defense: 10, symbol: 'üõ°Ô∏è' }
        ];
        const rarePotions = [
            { type: 'potion', name: 'Health Potion', effect: { health: 50 }, symbol: 'üß™' }
        ];

        const attackMultipliers = {
            normal: 1,
            strong: 1.5,
            veryStrong: 2,
            hyper: 3
        };

        const enemyAttackTypes = {
            grunt: { normal: 0.7, strong: 0.2, veryStrong: 0.1 },
            sniper: { normal: 0.5, strong: 0.3, veryStrong: 0.2 },
            tank: { normal: 0.4, strong: 0.3, veryStrong: 0.3 },
            summoner: { normal: 0.6, strong: 0.3, veryStrong: 0.1 },
            mage: { normal: 0.5, strong: 0.3, hyper: 0.2 }
        };

        function chooseAttackType(enemy) {
            const types = enemyAttackTypes[enemy.type];
            const rand = Math.random();
            let cumulative = 0;
            for (const [type, prob] of Object.entries(types)) {
                cumulative += prob;
                if (rand < cumulative) return type;
            }
            return 'normal';
        }

        function getArrowSize(damage) {
            const baseDamage = 10;
            return Math.min(3, damage / baseDamage);
        }

        function generateMap() {
            let map = Array(mapSize).fill().map(() => Array(mapSize).fill(0));
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    map[y][x] = Math.random() < 0.5 ? 1 : 0;
                }
            }
            for (let i = 0; i < 5; i++) {
                map = cellularAutomataStep(map);
            }
            for (let y = 1; y < mapSize - 1; y++) {
                for (let x = 1; x < mapSize - 1; x++) {
                    if (map[y][x] === 0 && isIsolated(x, y, map) && Math.random() < 0.1) {
                        map[y][x] = 1;
                    }
                }
            }
            map[1][1] = 0; // Start position
            map[8][8] = 0; // Exit position
            return isConnected(map) ? map : generateMap();
        }

        function isIsolated(x, y, map) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (map[y + dy][x + dx] === 1) return false;
                }
            }
            return true;
        }

        function cellularAutomataStep(map) {
            const newMap = map.map(row => row.slice());
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    newMap[y][x] = countWallNeighbors(map, x, y) >= 5 ? 1 : 0;
                }
            }
            return newMap;
        }

        function countWallNeighbors(map, x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || nx >= mapSize || ny < 0 || ny >= mapSize || map[ny][nx] === 1) count++;
                }
            }
            return count;
        }

        function isConnected(map) {
            const visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
            const queue = [[1, 1]];
            visited[1][1] = true;
            while (queue.length) {
                const [x, y] = queue.shift();
                for (const dir of Object.values(directions)) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && !visited[ny][nx] && map[ny][nx] === 0) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny]);
                    }
                }
            }
            return visited[8][8];
        }

        function generateEnemies(stage) {
            const baseHealth = 50 + (stage - 1) * 10;
            const baseAttack = 5 + Math.floor((stage - 1) / 2);
            const enemyTypes = [
                { type: 'grunt', maxHealth: baseHealth, health: baseHealth, attack: baseAttack, fireChance: 0.05, moveSpeed: 0.5, symbol: 'üëæ' },
                { type: 'sniper', maxHealth: baseHealth - 10, health: baseHealth - 10, attack: baseAttack + 2, fireChance: 0.1, moveSpeed: 0.7, symbol: 'üßü' },
                { type: 'tank', maxHealth: baseHealth + 20, health: baseHealth + 20, attack: baseAttack + 3, fireChance: 0, moveSpeed: 1, symbol: 'üëπ' },
                { type: 'summoner', maxHealth: baseHealth - 20, health: baseHealth - 20, attack: baseAttack - 2, fireChance: 0, moveSpeed: 1, symbol: 'üßô‚Äç‚ôÇÔ∏è', summonCooldown: 5 },
                { type: 'mage', maxHealth: baseHealth - 30, health: baseHealth - 30, attack: baseAttack, fireChance: 0, moveSpeed: 0.7, symbol: 'üßô‚Äç‚ôÄÔ∏è', spellCooldown: 3, spells: ['fireball', 'slow'] }
            ];
            const enemyList = [];
            const enemyCount = Math.min(3 + Math.floor(stage / 2), 10);
            for (let i = 0; i < enemyCount; i++) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8) || enemyList.some(e => e.x === x && e.y === y));
                const enemy = {
                    x, y, health: type.health, maxHealth: type.maxHealth,
                    attack: type.attack + Math.floor(Math.random() * 3) - 1,
                    moveCooldown: 0, fireCooldown: 0, type: type.type,
                    fireChance: type.fireChance + Math.random() * 0.05,
                    moveSpeed: type.moveSpeed + Math.random() * 0.2,
                    symbol: type.symbol, speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
                    renderX: x, renderY: y, bounceTargetX: null, bounceTargetY: null, bounceTimer: 0
                };
                if (type.type === 'summoner') enemy.summonCooldown = type.summonCooldown;
                if (type.type === 'mage') {
                    enemy.spellCooldown = type.spellCooldown;
                    enemy.spells = type.spells;
                }
                enemyList.push(enemy);
            }
            return enemyList;
        }

        function generateLoot() {
            const lootTypes = [
                { type: 'speed', name: 'Speed Boost', symbol: 'üèÉ', effect: (target) => target.speedBoostTimer = 10 },
                { type: 'damage', name: 'Mega Damage', symbol: 'üí™', effect: (target) => target.megaDamageTimer = 10 },
                { type: 'shield', name: 'Shield', symbol: 'üõ°Ô∏è', effect: (target) => target.shieldTimer = 5 },
                { type: 'teleport', name: 'Teleport', symbol: 'üîÆ', effect: (target) => teleportTarget(target) },
                { type: 'timeFreeze', name: 'Time Freeze', symbol: '‚è≥', effect: (target) => target.timeFreezeTimer = 5 },
                { type: 'invisibility', name: 'Invisibility', symbol: 'üëª', effect: (target) => target.invisibilityTimer = 10 },
                { type: 'doubleArrow', name: 'Double Arrow', symbol: 'üèπ', effect: (target) => target.doubleArrowTimer = 10 },
                { type: 'healthRegen', name: 'Health Regen', symbol: 'üíñ', effect: (target) => target.healthRegenTimer = 10 },
                { type: 'explosiveArrows', name: 'Explosive Arrows', symbol: 'üí£', effect: (target) => target.explosiveArrowsTimer = 10 }
            ];
            const lootList = [];
            for (let i = 0; i < 3; i++) {
                const type = lootTypes[Math.floor(Math.random() * lootTypes.length)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8) || lootList.some(l => l.x === x && l.y === y));
                lootList.push({ x, y, ...type });
            }
            return lootList;
        }

        function teleportTarget(target) {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (currentMap[y][x] !== 0);
            target.x = x;
            target.y = y;
        }

        function createParticles(x, y, count, color, speed, life) {
            if (particles.length + count > MAX_PARTICLES) {
                particles.splice(0, particles.length + count - MAX_PARTICLES);
            }
            for (let i = 0; i < count && particles.length < MAX_PARTICLES; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = (Math.random() * speed) + 1;
                particles.push({
                    x: x * cellSize + cellSize / 2,
                    y: y * cellSize + cellSize / 2,
                    dx: Math.cos(angle) * velocity,
                    dy: Math.sin(angle) * velocity,
                    life: life,
                    maxLife: life,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function createHealParticles(x, y) {
            createParticles(x, y, 20, 'lime', 1, 1);
            particles.slice(-20).forEach(p => p.dy -= 1);
        }

        function createExplosionParticles(x, y, damage) {
            const size = getArrowSize(damage);
            createParticles(x, y, 30 * size, 'yellow', 5, 0.3);
            createParticles(x, y, 20 * size, 'orange', 3, 0.5);
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx * deltaTime * 60;
                p.y += p.dy * deltaTime * 60;
                p.life -= deltaTime;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function startCountdown() {
            countdownActive = true;
            countdownTimer = 3.5;
            countdownText = '3';
            createParticles(mapSize / 2, mapSize / 2, 50, 'red', 2, 1);
        }

        function updateCountdown(deltaTime) {
            countdownTimer -= deltaTime;
            if (countdownTimer <= 0) {
                countdownActive = false;
                countdownText = '';
            } else if (countdownTimer <= 0.5) {
                if (countdownText !== 'GO!') {
                    countdownText = 'GO!';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'blue', 3, 1);
                }
            } else if (countdownTimer <= 1.5) {
                if (countdownText !== '1') {
                    countdownText = '1';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'green', 2, 1);
                }
            } else if (countdownTimer <= 2.5) {
                if (countdownText !== '2') {
                    countdownText = '2';
                    createParticles(mapSize / 2, mapSize / 2, 50, 'yellow', 2, 1);
                }
            }
        }

        function drawCountdown() {
            if (countdownActive) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(countdownText, logicalWidth / 2, logicalHeight / 2);
                ctx.restore();
            }
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pulseTime += 0.02;
            document.body.style.backgroundColor = `hsl(${stage * 10}, 50%, ${50 + Math.sin(pulseTime) * 10}%)`;

            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    if (currentMap[y][x] === 0) {
                        ctx.fillStyle = currentTileSet.floorColor;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        ctx.font = "30px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = 'black';
                        ctx.fillText(currentTileSet.wall, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
                    }
                }
            }

            if (exitUnlocked) {
                ctx.fillStyle = 'white';
                ctx.fillText("üö™", 8 * cellSize + cellSize / 2, 8 * cellSize + cellSize / 2);
            }

            loot.forEach(item => {
                ctx.save();
                ctx.translate(item.x * cellSize + cellSize / 2, item.y * cellSize + cellSize / 2);
                ctx.scale(1 + Math.sin(pulseTime * 2) * 0.1, 1 + Math.sin(pulseTime * 2) * 0.1);
                ctx.fillStyle = `hsl(${pulseTime * 100 % 360}, 100%, 70%)`;
                ctx.fillText(item.symbol, 0, 0);
                ctx.restore();
            });

            enemies.forEach(enemy => {
                const renderX = enemy.bounceTimer > 0 ? 
                    enemy.x + (enemy.bounceTargetX - enemy.x) * (1 - enemy.bounceTimer / 0.2) : enemy.x;
                const renderY = enemy.bounceTimer > 0 ? 
                    enemy.y + (enemy.bounceTargetY - enemy.y) * (1 - enemy.bounceTimer / 0.2) : enemy.y;
                ctx.fillText(enemy.symbol, renderX * cellSize + cellSize / 2, renderY * cellSize + cellSize / 2);
                const healthBarWidth = 30;
                const healthBarHeight = 5;
                const healthRatio = enemy.health / enemy.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth, healthBarHeight);
                ctx.fillStyle = `hsl(120, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)`;
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);
            });

            ctx.save();
            ctx.translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
            if (player.shieldTimer > 0) {
                ctx.strokeStyle = `hsl(240, 100%, ${50 + Math.sin(pulseTime * 3) * 20}%)`;
                ctx.lineWidth = 2 + Math.sin(pulseTime * 2);
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(pulseTime) * 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillText("üßô", 0, 0);
            ctx.restore();

            const healthBarWidth = 30;
            const healthBarHeight = 5;
            const healthRatio = player.health / player.maxHealth;
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);

            if (player.speedBoostTimer > 0) {
                player.trail.forEach((pos, i) => {
                    ctx.globalAlpha = 0.3 * (3 - i);
                    ctx.fillStyle = `hsl(${i * 60 + pulseTime * 100 % 360}, 100%, 50%)`;
                    ctx.fillText("üßô", pos.x * cellSize + cellSize / 2, pos.y * cellSize + cellSize / 2);
                });
                ctx.globalAlpha = 1;
            }
        }

        function drawArrows() {
            arrows.forEach(arrow => {
                const size = arrow.size || 1;
                ctx.strokeStyle = arrow.isPlayer ? (player.megaDamageTimer > 0 ? `hsl(300, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)` : 'blue') : 'red';
                ctx.lineWidth = (player.megaDamageTimer > 0 && arrow.isPlayer ? 4 : 2) * size;
                ctx.beginPath();
                ctx.moveTo(arrow.x * cellSize, arrow.y * cellSize);
                ctx.lineTo((arrow.x + arrow.dx * 0.5) * cellSize, (arrow.y + arrow.dy * 0.5) * cellSize);
                ctx.stroke();

                ctx.globalAlpha = 0.5;
                ctx.fillStyle = arrow.isPlayer ? 'cyan' : 'orange';
                ctx.beginPath();
                ctx.arc(arrow.x * cellSize, arrow.y * cellSize, 2 * size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function drawPopups() {
            popups.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = 'yellow';
                ctx.font = `16px Arial`;
                const scale = 1 + Math.sin(pulseTime * 5) * 0.2;
                ctx.save();
                ctx.translate(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2 - (1 - p.life / p.maxLife) * 20);
                ctx.scale(scale, scale);
                ctx.fillText(p.text, 0, 0);
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                if (player.speedBoostTimer > 0) {
                    player.trail.push({ x: player.x, y: player.y });
                    if (player.trail.length > 3) player.trail.shift();
                }
                player.x = newX;
                player.y = newY;
                const lootIndex = loot.findIndex(item => item.x === player.x && item.y === player.y);
                if (lootIndex >= 0) {
                    const item = loot[lootIndex];
                    if (item.type === 'potion' || item.effect) {
                        const quickSlotIndex = player.quickAccess.findIndex(slot => slot === null);
                        if (quickSlotIndex !== -1) {
                            player.quickAccess[quickSlotIndex] = item;
                        } else {
                            player.inventory.push(item);
                        }
                    } else if (item.type === 'weapon') {
                        const weaponSlotIndex = player.weaponQuickAccess.findIndex(slot => slot === null);
                        if (weaponSlotIndex !== -1) {
                            player.weaponQuickAccess[weaponSlotIndex] = item;
                        } else {
                            player.inventory.push(item);
                        }
                    } else {
                        player.inventory.push(item);
                    }
                    loot.splice(lootIndex, 1);
                    createParticles(player.x, player.y, 10, 'gold', 2, 0.5);
                    updateQuickAccessDisplay();
                    updateWeaponQuickAccessDisplay();
                    updateInventoryDisplay();
                }
                if (exitUnlocked && player.x === 8 && player.y === 8) advanceStage();
            }
        }

        function fireArrow(x, y, dx, dy, isPlayer = true, customDamage = null) {
            if (arrows.length >= MAX_ARROWS) return;  // Prevent arrow overflow
            const weaponBonus = isPlayer && player.equippedWeapon ? player.equippedWeapon.attack : 0;
            const baseDamage = isPlayer ? player.attack : 5;
            let damage = customDamage !== null ? customDamage : (isPlayer ? (player.megaDamageTimer > 0 ? (baseDamage + weaponBonus) * 2 : (baseDamage + weaponBonus)) : baseDamage);
            const size = getArrowSize(damage);
            const arrow = { 
                x: x + 0.5, y: y + 0.5, dx, dy, isPlayer, damage, size,
                isAoE: isPlayer && (player.equippedWeapon ? player.equippedWeapon.isAoE : false) || (player.explosiveArrowsTimer > 0)
            };
            if (player.equippedWeapon && player.equippedWeapon.spread && isPlayer && arrows.length + 2 < MAX_ARROWS) {
                arrows.push({ ...arrow, dx: dx + 0.1 });
                arrows.push({ ...arrow, dx: dx - 0.1 });
            }
            arrows.push(arrow);
            if (player.doubleArrowTimer > 0 && isPlayer && arrows.length < MAX_ARROWS) {
                arrows.push({ ...arrow, x: x + 0.5 + (dx * 0.1), y: y + 0.5 + (dy * 0.1) });
            }
            if (isPlayer) player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
        }

        function applyKnockback(target, dx, dy, distance = 1) {
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            if (magnitude === 0) return;
            const unitDx = dx / magnitude;
            const unitDy = dy / magnitude;
            target.bounceTargetX = Math.round(target.x + unitDx * distance);
            target.bounceTargetY = Math.round(target.y + unitDy * distance);
            if (target.bounceTargetX >= 0 && target.bounceTargetX < mapSize && target.bounceTargetY >= 0 && target.bounceTargetY < mapSize && currentMap[target.bounceTargetY][target.bounceTargetX] === 0) {
                target.bounceTimer = 0.2;
            } else {
                target.bounceTargetX = target.x;
                target.bounceTargetY = target.y;
            }
        }

        function dropLoot(x, y) {
            let drops = [];
            const roll = Math.random();
            const isLastEnemy = enemies.length === 1;
            if (roll < 0.5 || (isLastEnemy && !hasDroppedThisStage)) {
                let typeRoll = Math.random();
                let type = typeRoll < 0.7 ? rareWeapons : typeRoll < 0.9 ? rareArmor : rarePotions;
                drops.push({ x, y, ...type[Math.floor(Math.random() * type.length)] });
                hasDroppedThisStage = true;
            }
            if (Math.random() < 0.2) {
                let typeRoll = Math.random();
                let type = typeRoll < 0.7 ? rareWeapons : typeRoll < 0.9 ? rareArmor : rarePotions;
                drops.push({ x, y, ...type[Math.floor(Math.random() * type.length)] });
            }
            drops.forEach(drop => loot.push(drop));
        }

        function applyAoEDamage(centerX, centerY, damage) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < mapSize && y >= 0 && y < mapSize) {
                        for (let i = 0; i < enemies.length; i++) {
                            const enemy = enemies[i];
                            if (enemy.x === x && enemy.y === y && enemy.shieldTimer <= 0) {
                                enemy.health -= damage;
                                addDamagePopup(enemy.x, enemy.y, damage);
                                let knockDx = x - centerX;
                                let knockDy = y - centerY;
                                if (knockDx !== 0 || knockDy !== 0) applyKnockback(enemy, knockDx, knockDy, 1);
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(i, 1);
                                    i--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        function checkLevelUp() {
            if (player.xp >= player.xpToNext) {
                player.level += 1;
                player.xp -= player.xpToNext;
                player.xpToNext = Math.floor(player.xpToNext * 1.5);
                player.maxHealth += 20;
                player.health = player.maxHealth;
                player.attack += 5;
                showNotification(`Level Up! Level ${player.level}. Max Health: ${player.maxHealth}, Attack: ${player.attack}`);
                createParticles(player.x, player.y, 30, 'gold', 2, 1);
                updateInfo();
            }
        }

        function updateGameState(deltaTime) {
            if (countdownActive) {
                updateCountdown(deltaTime);
                return;
            }

            player.moveCooldown -= deltaTime;
            player.fireCooldown -= deltaTime;
            player.speedBoostTimer -= deltaTime;
            player.megaDamageTimer -= deltaTime;
            player.shieldTimer -= deltaTime;
            player.teleportTimer -= deltaTime;
            player.timeFreezeTimer -= deltaTime;
            player.invisibilityTimer -= deltaTime;
            player.doubleArrowTimer -= deltaTime;
            player.healthRegenTimer -= deltaTime;
            player.explosiveArrowsTimer -= deltaTime;
            player.slowTimer -= deltaTime;
            if (player.moveCooldown < 0) player.moveCooldown = 0;
            if (player.fireCooldown < 0) player.fireCooldown = 0;
            if (player.speedBoostTimer < 0) player.speedBoostTimer = 0;
            if (player.megaDamageTimer < 0) player.megaDamageTimer = 0;
            if (player.shieldTimer < 0) player.shieldTimer = 0;
            if (player.teleportTimer < 0) player.teleportTimer = 0;
            if (player.timeFreezeTimer < 0) player.timeFreezeTimer = 0;
            if (player.invisibilityTimer < 0) player.invisibilityTimer = 0;
            if (player.doubleArrowTimer < 0) player.doubleArrowTimer = 0;
            if (player.healthRegenTimer < 0) player.healthRegenTimer = 0;
            if (player.explosiveArrowsTimer < 0) player.explosiveArrowsTimer = 0;
            if (player.slowTimer < 0) player.slowTimer = 0;

            if (player.healthRegenTimer > 0 && player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + deltaTime * 10);
                createHealParticles(player.x, player.y);
                updateInfo();
            }

            const moveCooldown = player.speedBoostTimer > 0 ? 0.05 : (player.slowTimer > 0 ? 0.2 : 0.1);
            if (player.moveCooldown <= 0 && (movingUp || movingLeft || movingRight || movingDown)) {
                if (movingUp) movePlayer(0, -1);
                else if (movingDown) movePlayer(0, 1);
                else if (movingLeft) movePlayer(-1, 0);
                else if (movingRight) movePlayer(1, 0);
                player.moveCooldown = moveCooldown;
            }

            if (player.timeFreezeTimer <= 0) {
                enemies.forEach(enemy => {
                    enemy.moveCooldown -= deltaTime;
                    enemy.fireCooldown -= deltaTime;
                    if (enemy.moveCooldown < 0) enemy.moveCooldown = 0;
                    if (enemy.fireCooldown < 0) enemy.fireCooldown = 0;

                    if (enemy.bounceTimer > 0) {
                        enemy.bounceTimer -= deltaTime;
                        if (enemy.bounceTimer <= 0) {
                            enemy.x = enemy.bounceTargetX;
                            enemy.y = enemy.bounceTargetY;
                            enemy.bounceTimer = 0;
                        }
                    }

                    if (enemy.type === 'summoner') {
                        enemy.summonCooldown -= deltaTime;
                        if (enemy.summonCooldown <= 0) {
                            const possibleSpots = [];
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = enemy.x + dx;
                                    const ny = enemy.y + dy;
                                    if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && currentMap[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                        possibleSpots.push({x: nx, y: ny});
                                    }
                                }
                            }
                            if (possibleSpots.length > 0) {
                                const spot = possibleSpots[Math.floor(Math.random() * possibleSpots.length)];
                                const newEnemy = {
                                    x: spot.x, y: spot.y, health: 50, maxHealth: 50, attack: 5,
                                    moveCooldown: 0, fireCooldown: 0, type: 'grunt',
                                    fireChance: 0.05 + Math.random() * 0.05,
                                    moveSpeed: 0.5 + Math.random() * 0.2,
                                    symbol: 'üëæ', speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
                                    renderX: spot.x, renderY: spot.y, bounceTargetX: null, bounceTargetY: null, bounceTimer: 0
                                };
                                enemies.push(newEnemy);
                                enemy.summonCooldown = 5;
                                createParticles(spot.x, spot.y, 15, 'purple', 2, 0.5);
                            }
                        }
                    }

                    if (enemy.type === 'mage') {
                        enemy.spellCooldown -= deltaTime;
                        if (enemy.spellCooldown <= 0 && isInLineOfSight(enemy) && player.invisibilityTimer <= 0) {
                            const spell = enemy.spells[Math.floor(Math.random() * enemy.spells.length)];
                            if (spell === 'fireball') {
                                applyAoEDamage(player.x, player.y, 10);
                                addExplosion(player.x, player.y, false);
                                createExplosionParticles(player.x, player.y, 10);
                            } else if (spell === 'slow') {
                                player.slowTimer = 5;
                                createParticles(player.x, player.y, 15, 'gray', 1, 1);
                            }
                            enemy.spellCooldown = 3;
                        }
                    }

                    if (enemy.fireCooldown <= 0 && enemy.fireChance > 0 && Math.random() < enemy.fireChance && isInLineOfSight(enemy) && player.invisibilityTimer <= 0) {
                        const direction = getDirectionToPlayer(enemy);
                        if (direction) {
                            const attackType = chooseAttackType(enemy);
                            const multiplier = attackMultipliers[attackType];
                            const damage = enemy.attack * multiplier;
                            fireArrow(enemy.x, enemy.y, direction.dx, direction.dy, false, damage);
                            enemy.fireCooldown = 1;
                        }
                    }
                    if (enemy.moveCooldown <= 0) {
                        const target = getClosestTarget(enemy);
                        const dir = getDirectionToTarget(enemy, target);
                        const newX = enemy.x + dir.dx;
                        const newY = enemy.y + dir.dy;
                        if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                        enemy.moveCooldown = enemy.moveSpeed;
                    }
                });
            }

            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                arrow.x += arrow.dx * 5 * deltaTime;
                arrow.y += arrow.dy * 5 * deltaTime;
                const cellX = Math.floor(arrow.x);
                const cellY = Math.floor(arrow.y);

                if (cellX < 0 || cellX >= mapSize || cellY < 0 || cellY >= mapSize || currentMap[cellY][cellX] === 1) {
                    if (arrow.isAoE) {
                        applyAoEDamage(cellX, cellY, arrow.damage);
                        createExplosionParticles(cellX, cellY, arrow.damage);
                    } else {
                        createParticles(cellX, cellY, 10 * arrow.size, arrow.isPlayer ? 'blue' : 'red', 2, 0.3);
                    }
                    arrows.splice(i, 1);
                } else if (arrow.isPlayer) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (enemy.x === cellX && enemy.y === cellY) {
                            if (arrow.isAoE) {
                                applyAoEDamage(cellX, cellY, arrow.damage);
                                createExplosionParticles(cellX, cellY, arrow.damage);
                            } else if (enemy.shieldTimer <= 0) {
                                enemy.health -= arrow.damage;
                                const dx = enemy.x - player.x;
                                const dy = enemy.y - player.y;
                                applyKnockback(enemy, dx, dy, 2);
                                addDamagePopup(enemy.x, enemy.y, arrow.damage);
                                createParticles(enemy.x, enemy.y, 15 * arrow.size, 'orange', 2, 0.4);
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5);
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(j, 1);
                                    j--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                            arrows.splice(i, 1);
                            break;
                        }
                    }
                } else if (cellX === player.x && cellY === player.y) {
                    if (player.shieldTimer > 0) {
                        arrow.dx = -arrow.dx;
                        arrow.dy = -arrow.dy;
                        arrow.isPlayer = false;
                        createParticles(player.x, player.y, 10 * arrow.size, 'blue', 2, 0.3);
                        if (arrows.length + 4 < MAX_ARROWS) {
                            fireArrow(player.x, player.y, 0, -1, true);
                            fireArrow(player.x, player.y, 0, 1, true);
                            fireArrow(player.x, player.y, -1, 0, true);
                            fireArrow(player.x, player.y, 1, 0, true);
                        }
                    } else {
                        const damage = arrow.damage - (player.equippedArmor ? player.equippedArmor.defense : 0);
                        player.health -= Math.max(damage, 0);
                        applyKnockback(player, -arrow.dx, -arrow.dy, 1);
                        addDamagePopup(player.x, player.y, Math.max(damage, 0));
                        createParticles(player.x, player.y, 10 * arrow.size, 'red', 2, 0.3);
                        if (player.health <= 0) gameOver();
                        arrows.splice(i, 1);
                    }
                    updateInfo();
                }
            }

            updateParticles(deltaTime);
            for (let i = popups.length - 1; i >= 0; i--) {
                popups[i].life -= deltaTime;
                if (popups[i].life <= 0) popups.splice(i, 1);
            }
        }

        function renderScene() {
            drawMap();
            drawArrows();
            drawParticles();
            drawPopups();
            drawCountdown();
        }

        function gameLoop(timestamp) {
            const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1); // Cap deltaTime to prevent large jumps
            lastTimestamp = timestamp;
            updateGameState(deltaTime);
            renderScene();
            requestAnimationFrame(gameLoop);
        }

        function addDamagePopup(x, y, damage) {
            const roundedDamage = damage.toFixed(2);
            popups.push({ text: `-${roundedDamage}`, x, y, life: 1, maxLife: 1, isDamage: true });
        }

        function addExplosion(x, y, isPlayer) {
            popups.push({ text: 'üí•', x, y, life: 0.5, maxLife: 0.5, isDamage: false });
        }

        function gameOver() {
            player.health = Math.floor(player.maxHealth / 2);
            player.x = 1;
            player.y = 1;
            showNotification("You died! Respawned with half health.");
            createParticles(player.x, player.y, 20, 'purple', 2, 0.5);
            updateInfo();
        }

        function advanceStage() {
            stage++;
            player.x = 1;
            player.y = 1;
            currentMap = generateMap();
            enemies = generateEnemies(stage);
            loot = generateLoot();
            exitUnlocked = false;
            hasDroppedThisStage = false;
            currentTileSet = tileSets[(stage - 1) % tileSets.length];
            createParticles(player.x, player.y, 30, 'green', 3, 0.7);
            updateInfo();
            showNotification(`Welcome to Stage ${stage}!`);
            startCountdown();
        }

        function updateInfo() {
            document.getElementById('stage').innerText = `Stage: ${stage}`;
            document.getElementById('health').innerText = `Health: ${Math.floor(player.health)}/${player.maxHealth}`;
            document.getElementById('level').innerText = `Level: ${player.level}`;
            document.getElementById('xp').innerText = `XP: ${player.xp}/${player.xpToNext}`;
        }

        function isInLineOfSight(enemy) {
            const dx = Math.abs(enemy.x - player.x);
            const dy = Math.abs(enemy.y - player.y);
            if (dx === 0) {
                const y1 = Math.min(enemy.y, player.y);
                const y2 = Math.max(enemy.y, player.y);
                for (let y = y1 + 1; y < y2; y++) if (currentMap[y][enemy.x] === 1) return false;
                return true;
            } else if (dy === 0) {
                const x1 = Math.min(enemy.x, player.x);
                const x2 = Math.max(enemy.x, player.x);  // Fixed typo: Max.max -> Math.max
                for (let x = x1 + 1; x < x2; x++) if (currentMap[enemy.y][x] === 1) return false;
                return true;
            }
            return false;
        }

        function getDirectionToPlayer(enemy) {
            if (enemy.x === player.x) return enemy.y < player.y ? directions.down : directions.up;
            if (enemy.y === player.y) return enemy.x < player.x ? directions.right : directions.left;
            return null;
        }

        function getClosestTarget(enemy) {
            return player;
        }

        function getDirectionToTarget(enemy, target) {
            const dx = target.x - enemy.x;
            const dy = target.y - enemy.y;
            if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? directions.right : directions.left;
            return dy > 0 ? directions.down : directions.up;
        }

        function updateInventoryDisplay() {
            document.getElementById('equippedWeapon').textContent = `Weapon: ${player.equippedWeapon ? player.equippedWeapon.name : 'None'}`;
            document.getElementById('equippedArmor').textContent = `Armor: ${player.equippedArmor ? player.equippedArmor.name : 'None'}`;
            const list = document.getElementById('inventoryList');
            list.innerHTML = '';
            player.inventory.forEach((item, index) => {
                const li = document.createElement('li');
                li.textContent = item.name || item.type;
                li.draggable = true;
                li.setAttribute('data-index', index);
                li.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', index));
                const useButton = document.createElement('button');
                useButton.textContent = 'Use';
                useButton.addEventListener('click', () => useItem(index));
                li.appendChild(useButton);
                list.appendChild(li);
            });
        }

        function useItem(index) {
            const item = player.inventory[index];
            if (item.type === 'weapon') {
                if (player.equippedWeapon) player.inventory.push(player.equippedWeapon);
                player.equippedWeapon = item;
                player.inventory.splice(index, 1);
            } else if (item.type === 'armor') {
                if (player.equippedArmor) player.inventory.push(player.equippedArmor);
                player.equippedArmor = item;
                player.inventory.splice(index, 1);
            } else if (item.type === 'potion') {
                player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                player.inventory.splice(index, 1);
                createHealParticles(player.x, player.y);
                updateInfo();
            } else if (item.effect) {
                item.effect(player);
                player.inventory.splice(index, 1);
            }
            updateInventoryDisplay();
        }

        const quickSlots = document.querySelectorAll('.quickSlot');
        quickSlots.forEach(slot => {
            slot.addEventListener('click', () => useQuickAccessItem(parseInt(slot.getAttribute('data-slot'), 10)));
            slot.addEventListener('dragover', (e) => e.preventDefault());
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && (item.type === 'potion' || item.effect)) {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                    player.quickAccess[slotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateInventoryDisplay();
                    updateQuickAccessDisplay();
                }
            });
        });

        function updateQuickAccessDisplay() {
            quickSlots.forEach(slot => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.quickAccess[slotIndex];
                slot.querySelector('.item').textContent = item ? item.symbol : '';
            });
        }

        function useQuickAccessItem(slotIndex) {
            const item = player.quickAccess[slotIndex];
            if (item) {
                if (item.type === 'potion') {
                    player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                    player.quickAccess[slotIndex] = null;
                    createHealParticles(player.x, player.y);
                    updateInfo();
                } else if (item.effect) {
                    item.effect(player);
                    player.quickAccess[slotIndex] = null;
                }
                updateQuickAccessDisplay();
            }
        }

        const weaponSlots = document.querySelectorAll('.weaponSlot');
        weaponSlots.forEach(slot => {
            slot.addEventListener('click', () => equipWeaponFromQuickAccess(parseInt(slot.getAttribute('data-slot'), 10)));
            slot.addEventListener('dragover', (e) => e.preventDefault());
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && item.type === 'weapon') {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                    player.weaponQuickAccess[slotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateInventoryDisplay();
                    updateWeaponQuickAccessDisplay();
                }
            });
        });

        function updateWeaponQuickAccessDisplay() {
            weaponSlots.forEach(slot => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.weaponQuickAccess[slotIndex];
                slot.querySelector('.item').textContent = item ? item.symbol : '';
            });
        }

        function equipWeaponFromQuickAccess(slotIndex) {
            const weapon = player.weaponQuickAccess[slotIndex];
            if (weapon) {
                const temp = player.equippedWeapon;
                player.equippedWeapon = weapon;
                player.weaponQuickAccess[slotIndex] = temp;
                updateInventoryDisplay();
                updateWeaponQuickAccessDisplay();
            }
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
        }

        document.getElementById('moveUp').addEventListener('pointerdown', () => movingUp = true);
        document.getElementById('moveUp').addEventListener('pointerup', () => movingUp = false);
        document.getElementById('moveLeft').addEventListener('pointerdown', () => movingLeft = true);
        document.getElementById('moveLeft').addEventListener('pointerup', () => movingLeft = false);
        document.getElementById('moveRight').addEventListener('pointerdown', () => movingRight = true);
        document.getElementById('moveRight').addEventListener('pointerup', () => movingRight = false);
        document.getElementById('moveDown').addEventListener('pointerdown', () => movingDown = true);
        document.getElementById('moveDown').addEventListener('pointerup', () => movingDown = false);

        document.addEventListener('pointerup', () => {
            movingUp = movingLeft = movingRight = movingDown = false;
        });

        document.getElementById('fireUp').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0) {
                player.charging.up = true;
                player.chargeStartTime.up = performance.now();
            }
        });
        document.getElementById('fireUp').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.up) {
                const chargeTime = (performance.now() - player.chargeStartTime.up) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 0, -1, true, damage);
                player.charging.up = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireLeft').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0) {
                player.charging.left = true;
                player.chargeStartTime.left = performance.now();
            }
        });
        document.getElementById('fireLeft').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.left) {
                const chargeTime = (performance.now() - player.chargeStartTime.left) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, -1, 0, true, damage);
                player.charging.left = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireRight').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0) {
                player.charging.right = true;
                player.chargeStartTime.right = performance.now();
            }
        });
        document.getElementById('fireRight').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.right) {
                const chargeTime = (performance.now() - player.chargeStartTime.right) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 1, 0, true, damage);
                player.charging.right = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireDown').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (player.fireCooldown <= 0) {
                player.charging.down = true;
                player.chargeStartTime.down = performance.now();
            }
        });
        document.getElementById('fireDown').addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (player.charging.down) {
                const chargeTime = (performance.now() - player.chargeStartTime.down) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 0, 1, true, damage);
                player.charging.down = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'w') movingUp = true;
            if (e.key === 'a') movingLeft = true;
            if (e.key === 's') movingDown = true;
            if (e.key === 'd') movingRight = true;
            if (e.key === 'ArrowUp' && player.fireCooldown <= 0) {
                player.charging.up = true;
                player.chargeStartTime.up = performance.now();
            }
            if (e.key === 'ArrowLeft' && player.fireCooldown <= 0) {
                player.charging.left = true;
                player.chargeStartTime.left = performance.now();
            }
            if (e.key === 'ArrowRight' && player.fireCooldown <= 0) {
                player.charging.right = true;
                player.chargeStartTime.right = performance.now();
            }
            if (e.key === 'ArrowDown' && player.fireCooldown <= 0) {
                player.charging.down = true;
                player.chargeStartTime.down = performance.now();
            }
            if (e.key >= '1' && e.key <= '5') useQuickAccessItem(parseInt(e.key) - 1);
            if (e.key >= '6' && e.key <= '8') equipWeaponFromQuickAccess(parseInt(e.key) - 6);
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'w') movingUp = false;
            if (e.key === 'a') movingLeft = false;
            if (e.key === 's') movingDown = false;
            if (e.key === 'd') movingRight = false;
            if (e.key === 'ArrowUp' && player.charging.up) {
                const chargeTime = (performance.now() - player.chargeStartTime.up) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 0, -1, true, damage);
                player.charging.up = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
            if (e.key === 'ArrowLeft' && player.charging.left) {
                const chargeTime = (performance.now() - player.chargeStartTime.left) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, -1, 0, true, damage);
                player.charging.left = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
            if (e.key === 'ArrowRight' && player.charging.right) {
                const chargeTime = (performance.now() - player.chargeStartTime.right) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 1, 0, true, damage);
                player.charging.right = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
            if (e.key === 'ArrowDown' && player.charging.down) {
                const chargeTime = (performance.now() - player.chargeStartTime.down) / 1000;
                const multiplier = Math.min(3, 1 + chargeTime);
                const damage = (player.attack + (player.equippedWeapon ? player.equippedWeapon.attack : 0)) * multiplier;
                fireArrow(player.x, player.y, 0, 1, true, damage);
                player.charging.down = false;
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });

        document.getElementById('toggleInventory').addEventListener('click', () => {
            const inventoryDiv = document.getElementById('inventory');
            inventoryDiv.style.display = inventoryDiv.style.display === 'none' ? 'block' : 'none';
            if (inventoryDiv.style.display === 'block') updateInventoryDisplay();
        });

        startCountdown();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
