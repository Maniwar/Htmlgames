<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler - Mage Quest</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            transition: background-color 1s;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gameCanvas {
            border: 1px solid #000;
            display: block;
        }
        #controls {
            display: flex;
            justify-content: space-between;
            width: 400px;
            margin-top: 20px;
        }
        .dpad {
            width: 120px;
            height: 120px;
            position: relative;
        }
        .dpad button {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #ccc;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .up { top: 0; left: 40px; }
        .left { top: 40px; left: 0; }
        .right { top: 40px; left: 80px; }
        .down { bottom: 0; left: 40px; }
        #info {
            text-align: center;
            margin-bottom: 10px;
            font-family: Arial, sans-serif;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        #inventory {
            border: 1px solid gray;
            padding: 10px;
            display: none;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.8);
        }
        #inventoryList {
            list-style-type: none;
            padding: 0;
        }
        #inventoryList li {
            margin: 5px 0;
            cursor: move;
        }
        #inventoryList li button {
            margin-left: 10px;
        }
        #quickAccessBar {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        .quickSlot {
            width: 50px;
            height: 50px;
            border: 2px solid #ccc;
            margin: 0 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eee;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .quickSlot:hover {
            background-color: #ddd;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">
            <span id="stage">Stage: 1</span> | 
            <span id="health">Health: 100/100</span> | 
            <span id="level">Level: 1</span> | 
            <span id="xp">XP: 0/100</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="controls">
            <div id="movementDpad" class="dpad">
                <button class="up" id="moveUp">‚¨ÜÔ∏è</button>
                <button class="left" id="moveLeft">‚¨ÖÔ∏è</button>
                <button class="right" id="moveRight">‚û°Ô∏è</button>
                <button class="down" id="moveDown">‚¨áÔ∏è</button>
            </div>
            <div id="firingDpad" class="dpad">
                <button class="up" id="fireUp">üî•‚¨ÜÔ∏è</button>
                <button class="left" id="fireLeft">üî•‚¨ÖÔ∏è</button>
                <button class="right" id="fireRight">üî•‚û°Ô∏è</button>
                <button class="down" id="fireDown">üî•‚¨áÔ∏è</button>
            </div>
        </div>
        <button id="toggleInventory">Inventory</button>
        <div id="inventory">
            <h3>Equipped:</h3>
            <p id="equippedWeapon">Weapon: None</p>
            <p id="equippedArmor">Armor: None</p>
            <h3>Inventory:</h3>
            <ul id="inventoryList"></ul>
        </div>
        <div id="quickAccessBar">
            <div class="quickSlot" data-slot="0"></div>
            <div class="quickSlot" data-slot="1"></div>
            <div class="quickSlot" data-slot="2"></div>
            <div class="quickSlot" data-slot="3"></div>
            <div class="quickSlot" data-slot="4"></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 40;
        const mapSize = 10;
        const directions = {
            up: { dx: 0, dy: -1 },
            left: { dx: -1, dy: 0 },
            right: { dx: 1, dy: 0 },
            down: { dx: 0, dy: 1 }
        };

        let stage = 1;
        let player = {
            x: 1, y: 1, health: 100, maxHealth: 100, attack: 10, level: 1, xp: 0, xpToNext: 100,
            moveCooldown: 0, fireCooldown: 0, speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
            teleportTimer: 0, timeFreezeTimer: 0, invisibilityTimer: 0, doubleArrowTimer: 0,
            healthRegenTimer: 0, explosiveArrowsTimer: 0, trail: [],
            equippedWeapon: null, equippedArmor: null, inventory: [],
            quickAccess: [null, null, null, null, null]
        };
        let currentMap = generateMap();
        let enemies = generateEnemies(stage);
        let loot = generateLoot();
        let arrows = [];
        let popups = [];
        let particles = []; // New array for particle effects
        let movingUp = false, movingLeft = false, movingRight = false, movingDown = false;
        let exitUnlocked = false;
        let lastTimestamp = 0;
        let hasDroppedThisStage = false;
        let pulseTime = 0; // For pulsing effects

        // Rare Loot Definitions
        const rareWeapons = [
            { type: 'weapon', name: 'Bow', attack: 15, fireRate: 0.5, symbol: 'üèπ', spread: false, isAoE: false },
            { type: 'weapon', name: 'Crossbow', attack: 20, fireRate: 0.3, symbol: 'üèπ', spread: false, isAoE: false },
            { type: 'weapon', name: 'Shotgun', attack: 10, fireRate: 0.7, symbol: 'üî´', spread: true, isAoE: false },
            { type: 'weapon', name: 'Grenade Launcher', attack: 25, fireRate: 1.0, symbol: 'üí£', spread: false, isAoE: true },
            { type: 'weapon', name: 'Sniper Rifle', attack: 40, fireRate: 1.5, symbol: 'üî´', spread: false, isAoE: false },
            { type: 'weapon', name: 'Machine Gun', attack: 5, fireRate: 0.1, symbol: 'üî´', spread: false, isAoE: false }
        ];
        const rareArmor = [
            { type: 'armor', name: 'Leather Armor', defense: 5, symbol: 'üõ°Ô∏è' },
            { type: 'armor', name: 'Chainmail', defense: 10, symbol: 'üõ°Ô∏è' }
        ];
        const rarePotions = [
            { type: 'potion', name: 'Health Potion', effect: { health: 50 }, symbol: 'üß™' }
        ];

        // Procedural Map Generation
        function generateMap() {
            let map = Array(mapSize).fill().map(() => Array(mapSize).fill(0));
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    map[y][x] = Math.random() < 0.4 ? 1 : 0;
                }
            }
            for (let i = 0; i < 3; i++) {
                map = cellularAutomataStep(map);
            }
            map[1][1] = 0; // Start
            map[8][8] = 0; // Exit
            if (!isConnected(map)) return generateMap();
            return map;
        }

        function cellularAutomataStep(map) {
            const newMap = map.map(row => row.slice());
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    const wallNeighbors = countWallNeighbors(map, x, y);
                    newMap[y][x] = wallNeighbors >= 5 ? 1 : 0;
                }
            }
            return newMap;
        }

        function countWallNeighbors(map, x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || nx >= mapSize || ny < 0 || ny >= mapSize || map[ny][nx] === 1) count++;
                }
            }
            return count;
        }

        function isConnected(map) {
            const visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
            const queue = [[1, 1]];
            visited[1][1] = true;
            while (queue.length) {
                const [x, y] = queue.shift();
                for (const dir of Object.values(directions)) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && !visited[ny][nx] && map[ny][nx] === 0) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny]);
                    }
                }
            }
            return visited[8][8];
        }

        // Enemy and Loot Generation
        function generateEnemies(stage) {
            const baseHealth = 50 + (stage - 1) * 10;
            const baseAttack = 5 + Math.floor((stage - 1) / 2);
            const enemyTypes = [
                { type: 'grunt', maxHealth: baseHealth, health: baseHealth, attack: baseAttack, fireChance: 0.05, moveSpeed: 0.5, symbol: 'üëæ' },
                { type: 'sniper', maxHealth: baseHealth - 10, health: baseHealth - 10, attack: baseAttack + 2, fireChance: 0.1, moveSpeed: 0.7, symbol: 'üßü' },
                { type: 'tank', maxHealth: baseHealth + 20, health: baseHealth + 20, attack: baseAttack + 3, fireChance: 0, moveSpeed: 1, symbol: 'üëπ' }
            ];
            const enemyList = [];
            for (let i = 0; i < 3; i++) {
                const type = enemyTypes[Math.floor(Math.random() * 3)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8));
                enemyList.push({
                    x, y, health: type.health, maxHealth: type.maxHealth, attack: type.attack, moveCooldown: 0, fireCooldown: 0,
                    type: type.type, fireChance: type.fireChance, moveSpeed: type.moveSpeed, symbol: type.symbol,
                    speedBoostTimer: 0, megaDamageTimer: 0, shieldTimer: 0,
                    renderX: x, renderY: y, bounceTargetX: null, bounceTargetY: null, bounceTimer: 0
                });
            }
            return enemyList;
        }

        function generateLoot() {
            const lootTypes = [
                { type: 'speed', name: 'Speed Boost', symbol: 'üèÉ', effect: (target) => target.speedBoostTimer = 10 },
                { type: 'damage', name: 'Mega Damage', symbol: 'üí™', effect: (target) => target.megaDamageTimer = 10 },
                { type: 'shield', name: 'Shield', symbol: 'üõ°Ô∏è', effect: (target) => target.shieldTimer = 5 },
                { type: 'teleport', name: 'Teleport', symbol: 'üîÆ', effect: (target) => teleportTarget(target) },
                { type: 'timeFreeze', name: 'Time Freeze', symbol: '‚è≥', effect: (target) => target.timeFreezeTimer = 5 },
                { type: 'invisibility', name: 'Invisibility', symbol: 'üëª', effect: (target) => target.invisibilityTimer = 10 },
                { type: 'doubleArrow', name: 'Double Arrow', symbol: 'üèπ', effect: (target) => target.doubleArrowTimer = 10 },
                { type: 'healthRegen', name: 'Health Regen', symbol: 'üíñ', effect: (target) => target.healthRegenTimer = 10 },
                { type: 'explosiveArrows', name: 'Explosive Arrows', symbol: 'üí£', effect: (target) => target.explosiveArrowsTimer = 10 }
            ];
            const lootList = [];
            for (let i = 0; i < 3; i++) {
                const type = lootTypes[i];
                let x, y;
                do {
                    x = Math.floor(Math.random() * mapSize);
                    y = Math.floor(Math.random() * mapSize);
                } while (currentMap[y][x] !== 0 || (x === 1 && y === 1) || (x === 8 && y === 8) || lootList.some(l => l.x === x && l.y === y));
                lootList.push({ x, y, ...type });
            }
            return lootList;
        }

        function teleportTarget(target) {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (currentMap[y][x] !== 0);
            target.x = x;
            target.y = y;
        }

        // Particle System
        function createParticles(x, y, count, color, speed, life) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = (Math.random() * speed) + 1;
                particles.push({
                    x: x * cellSize + cellSize / 2,
                    y: y * cellSize + cellSize / 2,
                    dx: Math.cos(angle) * velocity,
                    dy: Math.sin(angle) * velocity,
                    life: life,
                    maxLife: life,
                    color: color
                });
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx * deltaTime * 60;
                p.y += p.dy * deltaTime * 60;
                p.life -= deltaTime;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Drawing Functions
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pulseTime += 0.02;
            document.body.style.backgroundColor = `hsl(${stage * 10}, 50%, ${50 + Math.sin(pulseTime) * 10}%)`;

            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    ctx.fillText(
                        (x === 8 && y === 8 && exitUnlocked) ? "üö™" : (currentMap[y][x] === 1 ? "üß±" : "‚¨ú"),
                        x * cellSize + cellSize / 2,
                        y * cellSize + cellSize / 2
                    );
                }
            }

            loot.forEach(item => {
                ctx.save();
                ctx.translate(item.x * cellSize + cellSize / 2, item.y * cellSize + cellSize / 2);
                ctx.scale(1 + Math.sin(pulseTime * 2) * 0.1, 1 + Math.sin(pulseTime * 2) * 0.1);
                ctx.fillStyle = `hsl(${pulseTime * 100 % 360}, 100%, 70%)`;
                ctx.fillText(item.symbol, 0, 0);
                ctx.restore();
            });

            enemies.forEach(enemy => {
                const renderX = enemy.bounceTimer > 0 ? 
                    enemy.x + (enemy.bounceTargetX - enemy.x) * (1 - enemy.bounceTimer / 0.2) : 
                    enemy.x;
                const renderY = enemy.bounceTimer > 0 ? 
                    enemy.y + (enemy.bounceTargetY - enemy.y) * (1 - enemy.bounceTimer / 0.2) : 
                    enemy.y;
                ctx.fillText(enemy.symbol, renderX * cellSize + cellSize / 2, renderY * cellSize + cellSize / 2);
                const healthBarWidth = 30;
                const healthBarHeight = 5;
                const healthRatio = enemy.health / enemy.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth, healthBarHeight);
                ctx.fillStyle = `hsl(120, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)`;
                ctx.fillRect(renderX * cellSize + (cellSize - healthBarWidth) / 2, renderY * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);
            });

            ctx.save();
            ctx.translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
            if (player.shieldTimer > 0) {
                ctx.strokeStyle = `hsl(240, 100%, ${50 + Math.sin(pulseTime * 3) * 20}%)`;
                ctx.lineWidth = 2 + Math.sin(pulseTime * 2);
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(pulseTime) * 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.fillText("üßô", 0, 0);
            ctx.restore();

            const healthBarWidth = 30;
            const healthBarHeight = 5;
            const healthRatio = player.health / player.maxHealth;
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x * cellSize + (cellSize - healthBarWidth) / 2, player.y * cellSize - 10, healthBarWidth * healthRatio, healthBarHeight);

            if (player.speedBoostTimer > 0) {
                player.trail.forEach((pos, i) => {
                    ctx.globalAlpha = 0.3 * (3 - i);
                    ctx.fillStyle = `hsl(${i * 60 + pulseTime * 100 % 360}, 100%, 50%)`;
                    ctx.fillText("üßô", pos.x * cellSize + cellSize / 2, pos.y * cellSize + cellSize / 2);
                });
                ctx.globalAlpha = 1;
            }
        }

        function drawArrows() {
            arrows.forEach(arrow => {
                ctx.strokeStyle = arrow.isPlayer ? (player.megaDamageTimer > 0 ? `hsl(300, 100%, ${50 + Math.sin(pulseTime * 5) * 20}%)` : 'blue') : 'red';
                ctx.lineWidth = player.megaDamageTimer > 0 && arrow.isPlayer ? 4 + Math.sin(pulseTime * 2) : 2;
                ctx.beginPath();
                ctx.moveTo(arrow.x * cellSize, arrow.y * cellSize);
                ctx.lineTo((arrow.x + arrow.dx * 0.5) * cellSize, (arrow.y + arrow.dy * 0.5) * cellSize);
                ctx.stroke();

                // Arrow trail
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = arrow.isPlayer ? 'cyan' : 'orange';
                ctx.beginPath();
                ctx.arc(arrow.x * cellSize, arrow.y * cellSize, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function drawPopups() {
            popups.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = 'yellow';
                ctx.font = `16px Arial`;
                const scale = 1 + Math.sin(pulseTime * 5) * 0.2;
                ctx.save();
                ctx.translate(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2 - (1 - p.life / p.maxLife) * 20);
                ctx.scale(scale, scale);
                ctx.fillText(p.text, 0, 0);
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        // Game Logic
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                if (player.speedBoostTimer > 0) {
                    player.trail.push({ x: player.x, y: player.y });
                    if (player.trail.length > 3) player.trail.shift();
                }
                player.x = newX;
                player.y = newY;
                const lootIndex = loot.findIndex(item => item.x === player.x && item.y === player.y);
                if (lootIndex >= 0) {
                    const item = loot[lootIndex];
                    if (item.type === 'potion' || item.effect) {
                        const quickSlotIndex = player.quickAccess.findIndex(slot => slot === null);
                        if (quickSlotIndex !== -1) {
                            player.quickAccess[quickSlotIndex] = item;
                        } else {
                            player.inventory.push(item);
                        }
                    } else {
                        player.inventory.push(item);
                    }
                    loot.splice(lootIndex, 1);
                    createParticles(player.x, player.y, 10, 'gold', 2, 0.5); // Pickup particles
                    updateQuickAccessDisplay();
                    updateInventoryDisplay();
                }
                if (exitUnlocked && player.x === 8 && player.y === 8) advanceStage();
            }
        }

        function fireArrow(x, y, dx, dy, isPlayer = true) {
            const weaponBonus = player.equippedWeapon ? player.equippedWeapon.attack : 0;
            const baseDamage = isPlayer ? player.attack : 5;
            const damage = (player.megaDamageTimer > 0 && isPlayer ? (baseDamage + weaponBonus) * 2 : (baseDamage + weaponBonus));
            const arrow = { 
                x: x + 0.5, 
                y: y + 0.5, 
                dx, 
                dy, 
                isPlayer, 
                damage, 
                isAoE: player.equippedWeapon ? player.equippedWeapon.isAoE : false 
            };
            if (player.equippedWeapon && player.equippedWeapon.spread && isPlayer) {
                arrows.push({ ...arrow, dx: dx + 0.1 });
                arrows.push({ ...arrow, dx: dx - 0.1 });
            }
            arrows.push(arrow);
            if (player.doubleArrowTimer > 0 && isPlayer) {
                arrows.push({ ...arrow, x: x + 0.5 + (dx * 0.1), y: y + 0.5 + (dy * 0.1) });
            }
            if (isPlayer) player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
        }

        function applyKnockback(target, dx, dy, distance = 1) {
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            if (magnitude === 0) return;
            const unitDx = dx / magnitude;
            const unitDy = dy / magnitude;
            target.bounceTargetX = Math.round(target.x + unitDx * distance);
            target.bounceTargetY = Math.round(target.y + unitDy * distance);
            if (target.bounceTargetX >= 0 && target.bounceTargetX < mapSize && target.bounceTargetY >= 0 && target.bounceTargetY < mapSize && currentMap[target.bounceTargetY][target.bounceTargetX] === 0) {
                target.bounceTimer = 0.2;
            } else {
                target.bounceTargetX = target.x;
                target.bounceTargetY = target.y;
            }
        }

        function dropLoot(x, y) {
            let drops = [];
            const roll = Math.random();
            const isLastEnemy = enemies.length === 1;

            if (roll < 0.5 || (isLastEnemy && !hasDroppedThisStage)) {
                let typeRoll = Math.random();
                let type;
                if (typeRoll < 0.7) type = rareWeapons;
                else if (typeRoll < 0.9) type = rareArmor;
                else type = rarePotions;
                const item = type[Math.floor(Math.random() * type.length)];
                drops.push({ x, y, ...item });
                hasDroppedThisStage = true;
            }

            if (Math.random() < 0.2) {
                let typeRoll = Math.random();
                let type;
                if (typeRoll < 0.7) type = rareWeapons;
                else if (typeRoll < 0.9) type = rareArmor;
                else type = rarePotions;
                const item = type[Math.floor(Math.random() * type.length)];
                drops.push({ x, y, ...item });
            }

            drops.forEach(drop => loot.push(drop));
        }

        function applyAoEDamage(centerX, centerY, damage) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < mapSize && y >= 0 && y < mapSize) {
                        for (let i = 0; i < enemies.length; i++) {
                            const enemy = enemies[i];
                            if (enemy.x === x && enemy.y === y && enemy.shieldTimer <= 0) {
                                enemy.health -= damage;
                                addDamagePopup(enemy.x, enemy.y, damage);
                                let knockDx = x - centerX;
                                let knockDy = y - centerY;
                                if (knockDx !== 0 || knockDy !== 0) {
                                    applyKnockback(enemy, knockDx, knockDy, 1);
                                }
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5); // Death particles
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(i, 1);
                                    i--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        function checkLevelUp() {
            if (player.xp >= player.xpToNext) {
                player.level += 1;
                player.xp -= player.xpToNext;
                player.xpToNext = Math.floor(player.xpToNext * 1.5);
                player.maxHealth += 20;
                player.health = player.maxHealth;
                player.attack += 5;
                alert(`Level Up! You are now Level ${player.level}. Max Health: ${player.maxHealth}, Attack: ${player.attack}`);
                createParticles(player.x, player.y, 30, 'gold', 2, 1); // Level-up particles
                updateInfo();
            }
        }

        function updateGameState(deltaTime) {
            player.moveCooldown -= deltaTime;
            player.fireCooldown -= deltaTime;
            player.speedBoostTimer -= deltaTime;
            player.megaDamageTimer -= deltaTime;
            player.shieldTimer -= deltaTime;
            player.teleportTimer -= deltaTime;
            player.timeFreezeTimer -= deltaTime;
            player.invisibilityTimer -= deltaTime;
            player.doubleArrowTimer -= deltaTime;
            player.healthRegenTimer -= deltaTime;
            player.explosiveArrowsTimer -= deltaTime;
            if (player.moveCooldown < 0) player.moveCooldown = 0;
            if (player.fireCooldown < 0) player.fireCooldown = 0;
            if (player.speedBoostTimer < 0) player.speedBoostTimer = 0;
            if (player.megaDamageTimer < 0) player.megaDamageTimer = 0;
            if (player.shieldTimer < 0) player.shieldTimer = 0;
            if (player.teleportTimer < 0) player.teleportTimer = 0;
            if (player.timeFreezeTimer < 0) player.timeFreezeTimer = 0;
            if (player.invisibilityTimer < 0) player.invisibilityTimer = 0;
            if (player.doubleArrowTimer < 0) player.doubleArrowTimer = 0;
            if (player.healthRegenTimer < 0) player.healthRegenTimer = 0;
            if (player.explosiveArrowsTimer < 0) player.explosiveArrowsTimer = 0;

            if (player.healthRegenTimer > 0) {
                player.health = Math.min(player.maxHealth, player.health + 1);
                createParticles(player.x, player.y, 5, 'lime', 1, 0.3); // Regen particles
                updateInfo();
            }

            const moveCooldown = player.speedBoostTimer > 0 ? 0.05 : 0.1;
            if (player.moveCooldown <= 0 && (movingUp || movingLeft || movingRight || movingDown)) {
                if (movingUp) movePlayer(0, -1);
                else if (movingDown) movePlayer(0, 1);
                else if (movingLeft) movePlayer(-1, 0);
                else if (movingRight) movePlayer(1, 0);
                player.moveCooldown = moveCooldown;
            }

            if (player.timeFreezeTimer <= 0) {
                enemies.forEach(enemy => {
                    enemy.moveCooldown -= deltaTime;
                    enemy.fireCooldown -= deltaTime;
                    if (enemy.moveCooldown < 0) enemy.moveCooldown = 0;
                    if (enemy.fireCooldown < 0) enemy.fireCooldown = 0;

                    if (enemy.bounceTimer > 0) {
                        enemy.bounceTimer -= deltaTime;
                        if (enemy.bounceTimer <= 0) {
                            enemy.x = enemy.bounceTargetX;
                            enemy.y = enemy.bounceTargetY;
                            enemy.bounceTimer = 0;
                        }
                    }

                    if (enemy.fireCooldown <= 0 && enemy.fireChance > 0 && Math.random() < enemy.fireChance && isInLineOfSight(enemy) && player.invisibilityTimer <= 0) {
                        const direction = getDirectionToPlayer(enemy);
                        if (direction) {
                            fireArrow(enemy.x, enemy.y, direction.dx, direction.dy, false);
                            enemy.fireCooldown = 1;
                        }
                    }
                    if (enemy.moveCooldown <= 0) {
                        const target = getClosestTarget(enemy);
                        const dir = getDirectionToTarget(enemy, target);
                        const newX = enemy.x + dir.dx;
                        const newY = enemy.y + dir.dy;
                        if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && currentMap[newY][newX] === 0) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                        enemy.moveCooldown = enemy.moveSpeed;
                    }
                });
            }

            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                arrow.x += arrow.dx * 5 * deltaTime;
                arrow.y += arrow.dy * 5 * deltaTime;
                const cellX = Math.floor(arrow.x);
                const cellY = Math.floor(arrow.y);

                if (cellX < 0 || cellX >= mapSize || cellY < 0 || cellY >= mapSize || currentMap[cellY][cellX] === 1) {
                    if (arrow.isAoE) {
                        applyAoEDamage(cellX, cellY, arrow.damage);
                    }
                    createParticles(cellX, cellY, 10, arrow.isPlayer ? 'blue' : 'red', 2, 0.3); // Wall hit particles
                    arrows.splice(i, 1);
                } else if (arrow.isPlayer) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (enemy.x === cellX && enemy.y === cellY) {
                            if (arrow.isAoE) {
                                applyAoEDamage(cellX, cellY, arrow.damage);
                            } else {
                                if (enemy.shieldTimer <= 0) {
                                    enemy.health -= arrow.damage;
                                    const dx = enemy.x - player.x;
                                    const dy = enemy.y - player.y;
                                    applyKnockback(enemy, dx, dy, 2);
                                    addDamagePopup(enemy.x, enemy.y, arrow.damage);
                                    createParticles(enemy.x, enemy.y, 15, 'orange', 2, 0.4); // Hit particles
                                }
                                if (enemy.health <= 0) {
                                    player.xp += 50;
                                    checkLevelUp();
                                    updateInfo();
                                    createParticles(enemy.x, enemy.y, 20, 'red', 3, 0.5); // Death particles
                                    dropLoot(enemy.x, enemy.y);
                                    enemies.splice(j, 1);
                                    j--;
                                    if (!enemies.length) exitUnlocked = true;
                                }
                            }
                            arrows.splice(i, 1);
                            break;
                        }
                    }
                } else if (cellX === player.x && cellY === player.y) {
                    if (player.shieldTimer > 0) {
                        arrow.dx = -arrow.dx;
                        arrow.dy = -arrow.dy;
                        arrow.isPlayer = false;
                        createParticles(player.x, player.y, 10, 'blue', 2, 0.3); // Deflection particles
                        fireArrow(player.x, player.y, 0, -1, true);
                        fireArrow(player.x, player.y, 0, 1, true);
                        fireArrow(player.x, player.y, -1, 0, true);
                        fireArrow(player.x, player.y, 1, 0, true);
                    } else {
                        const damage = arrow.damage - (player.equippedArmor ? player.equippedArmor.defense : 0);
                        player.health -= Math.max(damage, 0);
                        applyKnockback(player, -arrow.dx, -arrow.dy, 1);
                        addDamagePopup(player.x, player.y, Math.max(damage, 0));
                        createParticles(player.x, player.y, 10, 'red', 2, 0.3); // Damage particles
                        if (player.health <= 0) gameOver();
                        arrows.splice(i, 1);
                    }
                    updateInfo();
                }
            }

            updateParticles(deltaTime);
            for (let i = popups.length - 1; i >= 0; i--) {
                popups[i].life -= deltaTime;
                if (popups[i].life <= 0) popups.splice(i, 1);
            }
        }

        function renderScene() {
            drawMap();
            drawArrows();
            drawParticles();
            drawPopups();
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            updateGameState(deltaTime);
            renderScene();
            requestAnimationFrame(gameLoop);
        }

        // Helper Functions
        function addDamagePopup(x, y, damage) {
            popups.push({ text: `-${damage}`, x, y, life: 1, maxLife: 1, isDamage: true });
        }

        function addExplosion(x, y, isPlayer) {
            popups.push({ text: 'üí•', x, y, life: 0.5, maxLife: 0.5, isDamage: false });
        }

        function gameOver() {
            player.health = Math.floor(player.maxHealth / 2);
            player.x = 1;
            player.y = 1;
            alert("You died! Respawned with half health.");
            createParticles(player.x, player.y, 20, 'purple', 2, 0.5); // Respawn particles
            updateInfo();
        }

        function advanceStage() {
            stage++;
            player.x = 1;
            player.y = 1;
            currentMap = generateMap();
            enemies = generateEnemies(stage);
            loot = generateLoot();
            exitUnlocked = false;
            hasDroppedThisStage = false;
            createParticles(player.x, player.y, 30, 'green', 3, 0.7); // Stage advance particles
            updateInfo();
            alert(`Welcome to Stage ${stage}!`);
        }

        function updateInfo() {
            document.getElementById('stage').innerText = `Stage: ${stage}`;
            document.getElementById('health').innerText = `Health: ${player.health}/${player.maxHealth}`;
            document.getElementById('level').innerText = `Level: ${player.level}`;
            document.getElementById('xp').innerText = `XP: ${player.xp}/${player.xpToNext}`;
        }

        function isInLineOfSight(enemy) {
            const dx = Math.abs(enemy.x - player.x);
            const dy = Math.abs(enemy.y - player.y);
            if (dx === 0) {
                const y1 = Math.min(enemy.y, player.y);
                const y2 = Math.max(enemy.y, player.y);
                for (let y = y1 + 1; y < y2; y++) if (currentMap[y][enemy.x] === 1) return false;
                return true;
            } else if (dy === 0) {
                const x1 = Math.min(enemy.x, player.x);
                const x2 = Math.max(enemy.x, player.x);
                for (let x = x1 + 1; x < x2; x++) if (currentMap[enemy.y][x] === 1) return false;
                return true;
            }
            return false;
        }

        function getDirectionToPlayer(enemy) {
            if (enemy.x === player.x) return enemy.y < player.y ? directions.down : directions.up;
            if (enemy.y === player.y) return enemy.x < player.x ? directions.right : directions.left;
            return null;
        }

        function getClosestTarget(enemy) {
            return player;
        }

        function getDirectionToTarget(enemy, target) {
            const dx = target.x - enemy.x;
            const dy = target.y - enemy.y;
            if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? directions.right : directions.left;
            return dy > 0 ? directions.down : directions.up;
        }

        // Inventory Management
        function updateInventoryDisplay() {
            document.getElementById('equippedWeapon').textContent = `Weapon: ${player.equippedWeapon ? player.equippedWeapon.name : 'None'}`;
            document.getElementById('equippedArmor').textContent = `Armor: ${player.equippedArmor ? player.equippedArmor.name : 'None'}`;
            const list = document.getElementById('inventoryList');
            list.innerHTML = '';
            player.inventory.forEach((item, index) => {
                const li = document.createElement('li');
                li.textContent = item.name || item.type;
                li.draggable = true;
                li.setAttribute('data-index', index);
                li.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                });
                const useButton = document.createElement('button');
                useButton.textContent = 'Use';
                useButton.addEventListener('click', () => useItem(index));
                li.appendChild(useButton);
                list.appendChild(li);
            });
        }

        function useItem(index) {
            const item = player.inventory[index];
            if (item.type === 'weapon') {
                if (player.equippedWeapon) player.inventory.push(player.equippedWeapon);
                player.equippedWeapon = item;
                player.inventory.splice(index, 1);
            } else if (item.type === 'armor') {
                if (player.equippedArmor) player.inventory.push(player.equippedArmor);
                player.equippedArmor = item;
                player.inventory.splice(index, 1);
            } else if (item.type === 'potion') {
                player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                player.inventory.splice(index, 1);
                updateInfo();
            } else if (item.effect) {
                item.effect(player);
                player.inventory.splice(index, 1);
            }
            updateInventoryDisplay();
        }

        // Quick Access Bar Logic
        const quickSlots = document.querySelectorAll('.quickSlot');
        quickSlots.forEach((slot) => {
            slot.addEventListener('click', () => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.quickAccess[slotIndex];
                if (item) {
                    if (item.type === 'potion') {
                        player.health = Math.min(player.maxHealth, player.health + item.effect.health);
                        player.quickAccess[slotIndex] = null;
                        updateInfo();
                    } else if (item.effect) {
                        item.effect(player);
                        player.quickAccess[slotIndex] = null;
                    }
                    updateQuickAccessDisplay();
                }
            });
            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                const index = e.dataTransfer.getData('text/plain');
                const item = player.inventory[index];
                if (item && (item.type === 'potion' || item.effect)) {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                    player.quickAccess[slotIndex] = item;
                    player.inventory.splice(index, 1);
                    updateInventoryDisplay();
                    updateQuickAccessDisplay();
                }
            });
        });

        function updateQuickAccessDisplay() {
            quickSlots.forEach(slot => {
                const slotIndex = parseInt(slot.getAttribute('data-slot'), 10);
                const item = player.quickAccess[slotIndex];
                slot.innerHTML = item ? item.symbol : '';
            });
        }

        // Event Listeners for Movement and Firing
        document.getElementById('moveUp').addEventListener('pointerdown', () => movingUp = true);
        document.getElementById('moveUp').addEventListener('pointerup', () => movingUp = false);
        document.getElementById('moveLeft').addEventListener('pointerdown', () => movingLeft = true);
        document.getElementById('moveLeft').addEventListener('pointerup', () => movingLeft = false);
        document.getElementById('moveRight').addEventListener('pointerdown', () => movingRight = true);
        document.getElementById('moveRight').addEventListener('pointerup', () => movingRight = false);
        document.getElementById('moveDown').addEventListener('pointerdown', () => movingDown = true);
        document.getElementById('moveDown').addEventListener('pointerup', () => movingDown = false);

        document.addEventListener('pointerup', () => {
            movingUp = movingLeft = movingRight = movingDown = false;
        });

        document.getElementById('fireUp').addEventListener('click', () => {
            if (player.fireCooldown <= 0) {
                fireArrow(player.x, player.y, 0, -1);
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireLeft').addEventListener('click', () => {
            if (player.fireCooldown <= 0) {
                fireArrow(player.x, player.y, -1, 0);
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireRight').addEventListener('click', () => {
            if (player.fireCooldown <= 0) {
                fireArrow(player.x, player.y, 1, 0);
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });
        document.getElementById('fireDown').addEventListener('click', () => {
            if (player.fireCooldown <= 0) {
                fireArrow(player.x, player.y, 0, 1);
                player.fireCooldown = player.equippedWeapon ? player.equippedWeapon.fireRate : 0.5;
            }
        });

        document.getElementById('toggleInventory').addEventListener('click', () => {
            const inventoryDiv = document.getElementById('inventory');
            inventoryDiv.style.display = inventoryDiv.style.display === 'none' ? 'block' : 'none';
            updateInventoryDisplay();
        });

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
